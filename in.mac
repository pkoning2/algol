TITLE	IN,<ALGOL INITIALIZATION>,09,11-OCT-80,TG/GPK

	$LIST$	=	1		;LIST COMMON FILE

;	ENTRY POINT TO THIS MODULE:

; INIT		- ENTRY FROM P.RUN

;	ROUTINES CALLED FROM THIS MODULE:

;+
; SYSTEM	- IO - SYSTEM I/O OPERATIONS
; MEMSIZ 	- IO - GET MEMORY SIZE
; ERR		- IO - PRINT ERROR INFO
; CONVRT	- SB - CONVERT A NUMBER
; ERROR		- SB - PRINT AN ERROR
; GETSPC	- ME - GET MEMORY SPACE
; SBR		- RC - START INTERPRETER
;-
.SBTTL	ALGOL INITIALIZATION CODE
;+
;	I N I T
;
; THIS ROUTINE SETS UP THE USER LOW CORE AREA, ASKS FOR A
; CODE FILE NAME, READS THAT CODE FILE, AND BEGIN EXECUTING
; IT.  A NULL CODE FILE SPECIFIES THE COMPILER ([1,2]ALGOL.ALC)
;-

	ORG	IN
INIT::	.NAME				; NAME WHAT WE GOT FOR NOW PLEASE
	CLR	ALGOL			;SAY WE AREN'T IN THE INTERPRETER YET
	MOV	#100001,@#OPNFLG	; CHANNEL 0,15 OPEN, 1-14 CLOSED

;	SET UP MEMORY LIST

	CALLX	MEMSIZ			; GET US CORE AND TELL US HOW MUCH
	MOV	#M.LOCK,-(R0)		;MAKE A BUFFER ZONE FOR FORGET
	MOV	R0,M$LAST		;SAVE THE END JUST IN CASE
	MOV	#M$STRT,R1		;GET THE FIXED BEGINNING OF MEMORY
	MOV	#M.LOCK,(R1)+		;AND LOCK THE SEGMENT TOO
	CLR	(R1)+			;DON'T KNOW THE LINK YET
	CLR	(R1)+			;THIS ONE HAS NO SIZE
	CLR	(R1)+			;AND THUS NO OWNER
	CLR	(R1)+			;I SAID IT HAD NO SIZE
	MOV	R1,-10(R1)		;NOW WE CAN LINK IT TO HERE
	CLR	(R1)+			;THIS ONE IS AVAILABLE
	CLR	(R1)+			;AND NONE FOLLOW IT
	CLR	(R1)+			;DON'T KNOW IT'S SIZE YET
	CLR	(R1)+			;IT'S FREE, SO NO-ONE OWNS IT
	TST	-(R0)			;GET TO LAST OF THAT SEGMENT
	MOV	R0,R2			;COPY POINTER TO END
	SUB	R1,R2			;TO CALCULATE IT'S SIZE
	MOV	R2,(R0)			;PUT SIZE AT THE END
	MOV	R2,-4(R1)		;AND ALSO AT THE FRONT

;	INIT LOW CORE

	MOV	#FRAME,R0		;GET THE POINTER TO LOW CORE STUFF
	MOV	(R0)+,R1		;THIS TELLS WHERE TO PUT IT
	MOV	(R0)+,R2		;THIS TELLS HOW MANY
10$:	MOV	(R0)+,(R1)+		;MOVE ONE DOWN
	SOB	R2,10$			;UNTIL WE'VE DONE THEM ALL
	MOV	(R0)+,R2		;THIS IS HOW MANY TO ZERO
20$:	CLR	(R1)+			;NOW CLEAR ONE
	SOB	R2,20$			;UNTIL WE GET THEM ALL
	MOV	(R0)+,R2		;THIS IS HOW MANY ODD ONES
30$:	MOV	(R0)+,@(R0)+		;WHAT TO PUT AND WHERE TO PUT IT
	SOB	R2,30$			;LOOP UNTIL DONE

;	OPEN/KILL OVERLAY FILE

	MOVB	@#FIRQB+FQJOB,R1	;GET OUR JOB NUMBER
	ASR	R1			; NOT TIMES TWO!
	MOV	#10.,R2			;CONVERT IT IN DECIMAL
	MOV	#2,-(SP)		;FOR TWO DIGITS
	MOV	#XXSPOT,R5		;AND PUT THEM THERE
	CALLX	CONVRT			; DO THE CONVERSION
	MOV	#VMEMFD,SYS.FD		;WANT TO OPEN OVERLAY FILE
	MOV	#IO.OP,SYS.IO		;AND THAT IS THE CODE
	CALLX	SYSTEM			; AND THAT DOES IT
	MOV	#IO.DE,SYS.IO		;CALL FOR DELETE
	CALLX	SYSTEM			; AND MAKE IT DISAPPEAR

;	NOW RUN THE CODE FILE

	MOV	#PROGFD,@#SYS.FD	; POINT TO CODE FD
	MOVB	#'T,@#PROGID+6		; TO FAKE OUT SCANNER
	MOV	#IO.RN,@#SYS.IO		; SPECIAL RUN CODE
	CALLX	SYSTEM			; AND GO DO IT PLEASE
	MOV	#IOBUFF,SYS.CA		;READ INTO IOBUFF
	MOV	#10.*2,SYS.CT		;READ 10. WORDS
	MOV	#IO.RD,@#SYS.IO		; READ PLEASE
	CLR	SYS.RN			;READ RECORD ZERO
	CALLX	SYSTEM			; READ IT
	TST	IOBUFF+2		;GOT ANY PRT HERE?
	BEQ	40$			;NO, CAN'T BE A CODE FILE
	COM	IOBUFF+14		;THIS ONE SHOULD HAVE BEEN -1
	ADD	IOBUFF+14,IOBUFF+4 	;RESULT BETTER BE ZERO
	BEQ	50$			;SURE IS, MAYBE IT'S CODE

40$:	QUIT	<?Not a valid code file>

50$:	CMP	IOBUFF+22,#REVNO 	;COMPILER COMPATIBLE???
	BEQ	60$			;YEAH, GOT IT MADE

	QUIT	<?Compiler version is incompatable - Can't run>

60$:	MOV	IOBUFF+2,R0		;GET SIZE OF PRT
	ASL	R0			;CONVERT TO BYTES
	MOV	R0,SYS.CT		;SAVE SIZE FOR DISK READ
	ADD	#STACK*2,R0		;PLUS ROOM FOR A STACK
	MOV	#M.PRT,R1		;TYPE IS 'PRT'
	CALLX	GETSPC			; MAKE ROOM FOR A BIGGIE
	TST	(R0)+			;MOVE UP TO START OF PRT
	MOV	R0,SYS.CA		;ADDRESS OF PRT FOR DISK READ
	MOV	R0,R3			;COPY INTO R REGISTER
	ADD	IOBUFF+2,R0		;MOVE UP TO BOTTOM OF STACK
	ADD	IOBUFF+2,R0		;IN WORDS NOT BYTES
	MOV	R0,STKLIM		;BOTTOM LIMIT FOR STACK
	ADD	#100,STKLIM		;IS A LITTLE UP FROM HERE
	ADD	#STACK*2,R0		;THIS IS WHERE OUT STACK BEGIN
	MOV	R0,SP			;NOW SET IT UP
	MOV	R0,R4			;AND SET UP THE F REGISTER
	MOV	IOBUFF,SYS.RN		;THIS IS THE BLOCK TO READ
	CALLX	SYSTEM			; READ THE WOLE PRT
	MOV	#-1,-(SP)		;THIS LETS COM11 WORK
	CLR	-(SP)			;DUMMY FILE POINTER
	CLR	-(SP)			;DUMMY POINTER POINTER
	MOV	SP,FSTPTR		;LINK IT UP
	MOV	SP,PTRLNK		;AND LINK IT DOWN
	CLR	-(SP)			;DUMMY ARRAY POINTER
	MOV	SP,ARYLNK		;AND LINK IT UP
	MOV	SP,FSTARY		; ... AND DOWN
	MOV	R3,PRT			;FOR SAFE KEEPING
	MOV	R3,-(SP)		;FAKE A MARK STACK
	MOV	SP,(R3)			;LIKE SO
	ADD	#30,(SP)		;NOW POINT TO CODE SEGMENT
	COM	ALGOL			;WE NOW BEGIN INTERPRETING
	JMPX	SBR			; LIKE SO

COMPIL:	.ASCII	/[1,2]ALGOL/
	.ASCII	<NULL><FF><ESC>
CDMESS:	.ASCII	<CR><LF>
CHRTBL:
	.EVEN				;ALWAYS DO THIS
;+
;	THIS DATA COMPRISES THE NON-ZERO VALUES WHICH MUST BE SET
;	INTO THE LOW CORE AREA.  THE RELATIVE POSITION OF THESE
;	DATA ARE CHECKED AGAINST THE DEFINITIONS OF LOW CORE ASSIGNMENT.
;-

	.MACRO	CHECK	L0,L1
	.IF	NE	<L0-FILINK>-<L1-10$>
	.ERROR				;INCONSISTENCY IN THE ASSIGNMENT OF L0
	.ENDC
	.ENDM

	ORG	CO
FRAME:	.WORD	FILINK			;START INITIALIZING HERE
	.WORD	<70$-10$>/2		;THIS MANY GET INITIALIZED.
10$:	.WORD	PROGFD			;FILINK
	CHECK	FILINK,10$
20$:	.WORD	VMEMFD			;FSTFIL
	CHECK	FSTFIL,20$
30$:	.WORD	<BLKSIZ*2>*10+0		;VMEMFD
	.WORD	VMEMID
	.WORD	3			; OPEN AS FILE
	.WORD	PROGFD
	.WORD	255.
	CHECK	VMEMFD,30$
40$:	.WORD	VMEMFD			;VMEMID
	.WORD	0
	.WORD	VMLINK
	.ASCIZ	/WF:SWAPXX.TMP/
	.EVEN
	CHECK	VMEMID,40$
	CHECK	XXSPOT,40$+15
	CHECK	DOTALG,40$+17
50$:	.WORD	<BLKSIZ*2>*10+0		;PROGFD
	.WORD	PROGID			; ALGOL FIB
	.WORD	1			; OPEN FOR INPUT
	.WORD	0
	.WORD	400
	CHECK	PROGFD,50$
60$:	.WORD	PROGFD			;PROGID
	.WORD	0			; 100000 = OPEN
	.WORD	PRLINK			; --> RSTS FIB
	CHECK	PROGID,60$
70$:
	CHECK	$ZERO0,70$
	.WORD	<$ZERO1-$ZERO0>/2 	;THIS MANY GET ZEROED
	.WORD	<90$-80$>/4		;THIS MANY ODDBALLS
80$:	.WORD	VMEMFD
	.WORD	VMLINK-2
	.WORD	PROGFD
	.WORD	PRLINK-2
	.WORD	100000
	.WORD	OVRMAP
	.WORD	177777
	.WORD	OVRMAP+22
	.WORD	PRDESC+6
	.WORD	PBASE
	.WORD	PRDESC-40		;SET UP PRT TO DUMMY SO INITIAL READ
	.WORD	PRT			;OF 10 WORDS DOESN'T SCREW
90$:
	.END

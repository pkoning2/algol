TITLE	IO,<ALGOL/RSTS INTERFACE ROUTINES>,08,06-SEP-80,TG/GPK

;	ENTRY POINTS TO THIS MODULE

;+
; GETIME	- GET TIME
; GEDATE	- GET THE DATE
; EXIT		- GO AWAY
; MEMSIZ	- GET MEMORY SIZE
; SYSTEM	- DO ALL I/O
; CTRLC		- ^C TYPED
; ERR		- ERROR ROUTINE
;-

;	ROUTINES CALLED FROM THIS MODULE

;+
; CSI		- SC - FILE NAME SCANNER
; ERROR		- SB - PRINT AND ERROR MESSAGE
; GETSPC	- ME - GET SPACE
; FORGET	- ME -
;-
.SBTTL	GET TIME

;+
;	G E T I M E
;
; CALL:	JSR	PC,GETIME
; 
; RETURN:
;  R0 = SECONDS
;  R1 = MINUTES
;  R2 = HOUR
; 
; NOTE:	THE .DATE MONITOR CALL RETURNS:
; 	  XRB	 = DATE ( (YEARS-1970)*1000+DAY OF YEAR)
; 	  XRB+2	 = TIME (MINUTES BEFORE MIDNIGHT)
; 	  XRB+4	 = TIME (SECONDS TO NEXT MINUTE)
; 	  XRB+5	 = TIME (TICKS TO NEXT SECOND)
; 	  XRB+6	 = NAME1
; 	  XRB+10 = NAME2
; 	  XRB+12 = RTS1
; 	  XRB+14 = RTS2
;-

	ORG	IO
GETIME::.DATE				;GET INFO
	MOV	#1440.,R1		;MINUTES IN A DAY
	SUB	XRB+2,R1		;NOW MINUTES SINCE MIDNIGHT
	CLR	R0			;CLEAR MOST SIGNIFICANT REG FOR DIVIDE
	DIV	#60.,R0			;NOW HOURS WITH MINUTES IN R1 (NEAT HUH?)
	MOV	R0,R2			;PUT IT WHERE HOSLER WANTS IT
	MOV	#60.,R0			;SECONDS IN A MINUTE
	CLRB	XRB+5			;GET RID OF TICKS
	SUB	XRB+4,R0		;NOW SECONDS AFTER MINUTE
	RTS	PC			;AND RETURN
.SBTTL	GET DATE

;+
;	G E D A T E
;
; CALL:	JSR	PC,GEDATE
; 
; RETURN:
;  R0 = DAY OF MONTH
;  R1 = MONTH OF YEAR (1 TO 12)
;  R2 = JULIAN YEAR
; 
; NOTE: SEE GET TIME (GETIME) FOR INFORMATION CONCERNING THE
; 	.DATE MONITOR CALL
;-

GEDATE::.DATE				;GET INFO
	CLR	R0			;CLEAR HIGH ORDER
	MOV	XRB,R1			;PUT DATE IN LOW ORDER
	DIV	#1000.,R0		;SEPARATE YEARS FROM DAYS
	ADD	#1970.,R0		;MAKE YEAR JULIAN
	MOV	R0,R2			;PUT IT WHERE HOSLER WANTS IT
	BIT	#3,R0			;LEAP YEAR? (DIVISABLE BY FOUR)
	BEQ	10$			;YUP
	CMP	R1,#60.			;IS IT PAST 2/28?
	BLT	10$			;NO, DAYS ARE OK
	INC	R1			;YES, SKIP 2/29
10$:	MOV	R1,R0			;SAVE NUMBER OF DAYS (.DIV SET R1 FOR US)
	MOV	#30$,R1			;GET POINTER TO MONTH TABLE
20$:	SUB	(R1)+,R0		;TEST FOR THE RIGHT MONTH
	BGT	20$			;UNTIL WE GO TOO FAR
	ADD	-2(R1),R0		;FIX UP DAYS
	SUB	#30$,R1			;NOW FIX UP MONTHS
	ASR	R1			;WE WERE COUNTING BY TWOSIES
	RTS	PC			;AND RETURN

30$:	.WORD	31.,29.,31.,30.,31.,30.,31.,31.,30.,31,30.,31.
.SBTTL	EXIT

;+
;	E X I T
;
; CALL:	BR  EXIT   OR   JMP EXIT   OR   JSR  PC,EXIT
; 
; RETURN:
;  IT DOESN'T!
;-

EXIT::	CALL	CLRFQB			; CLEAR HIM OUT PLEASE
	MOVB	#RSTFQ,@#FIRQB+FQFUN	; SET IN RESET FUNCTION
	CALFIP				; DO IT
	CALL	CLRFQB			; CLEAR OUT THE FIRQB PLEASE
	.RTS				; AND GO AWAY
	.EXIT				; ? IT WAS LITTLE OL' ME ???
.SBTTL	SET UP CORE LIMITS

;+
;	M E M S I Z
;
; THIS ROUTINE ALLOCATES AS MUCH CORE AS RSTS WILL ALLOW
; TO THE ALGOL OPERATING SYSTEM.  THE ADDRESS OF THE WORD
; OF MEMORY ABOVE THE LAST AVAIABLE WORD IS RETURNED IN R0.
;
; CALLING SEQUENCE:
;
;	JSR	PC,MEMSIZ
;-


MEMSIZ::MOV	P.SIZE,XRB		;SET TO GET US THE MAX
10$:	.CORE				;GET IT
	TST	IOSTS			;DID IT WORK?
	BEQ	20$			;YEP, RETURN RESULTS
	DECB	XRB			;NOPE, TRY FOR A LITTLE LESS
	BR	10$			;UNTIL WE GET SOME
20$:	MOVB	XRB,R0			;GET THE SIZE WE GOT
	ASH	#11.,R0			;AND MAKE IT INTO BYTES
	RTS	PC			;AND EXIT
.SBTTL	SYSTEM FILE ROUTINES

;+
;	S Y S T E M
;
; CALL:	JSR	PC,SYSTEM
;
;	PARAMETERS ARE PASSED IN THE SYSTEM
;	TRANSFER CONTROL BLOCK:
;
;	SYS.IO:	I/O REQUEST CODE
;	SYS.FD:	ADDRESS OF FILE DESCRIPTOR
;	SYS.CT:	TRANSFER COUNT (IN BYTES)
;	SYS.CA:	BUFFER ADDRESS
;	SYS.RN:	RECORD NUMBER
;
; 
; RETURN:
;  ALL REGISTERS ARE SAVED.  FATAL ERRORS ARE HANDLED BY THESE ROUTINES.
; 
; NOTE:	I/O REQUEST CODES:
; 		0 = READ	- IO.RD
; 		1 = WRITE	- IO.WT
; 		2 = OPEN	- IO.OP
; 		3 = CLOSE	- IO.CL
; 		4 = DELETE	- IO.DE
; 		5 = GET STATUS	- IO.ST
;		6 = MARK RUN FILE OPEN - IO.RN
;-

SYSTEM::MOV	R0,-(SP)		;SAVE R0
	MOV	R1,-(SP)		;SAVE R1
	MOV	R2,-(SP)		;SAVE R2
	MOV	R3,-(SP)		;SAVE R3
	MOV	R4SAVE,-(SP)		;STACK OLD R4
	MOV	R4,R4SAVE		;SAVE R4
	MOV	SYS.IO,R0		;GET I/O REQUEST
	ASL	R0			;PREPARE FOR TRICKY STUFF
	JMP	@FUNCAL(R0)		;ZINGO!!
FUNCAL:	READ				;READ FROM A FILE
	WRITE				;WRITE A FILE
	OPEN				;OPEN A FILE
	CLOSE				;CLOSE A FILE
	DELETE				;DELETE A FILE
	STATUS				;GET STATUS
	RUNOPN				; RUN FILE
.SBTTL	OPEN A FILE

OPEN:	CALL	SETFQB			; SET UP FIRQB
	MOV	OPNFLG,R2		;OPEN FILE FLAG
	COM	R2			;ANY CHANNELS FREE?
	BNE	10$			;GOOD THING
	MOVB	#DTOOOF,@#IOSTS		; SET TOO MANY OPEN FILES ERROR
	JMP	ERR			;GIVE IT TO HIM
10$:	MOV	#1,R3			;WE'LL USE THIS TO UPDATE OPNFLG
	CLR	R4			;CHANNEL NUMBER - START WITH ZERO
20$:	ROR	R2			;CHECK FOR FREE CHANNEL
	BCS	30$			;FOUND ONE!
	ROL	R3			;SET R3 TO NEXT CHANNEL
	INC	R4			;INCREMENT CHANNEL NUMBER
	BR	20$			;AND KEEP LOOKING
30$:	ADD	R4,R4			;NOW CHANNEL NUMBER TIMES TWO
	MOV	R4,@#FIRQB+FQFIL	;SET INTO FIRQB
	BIT	#OPN.IN,4(R0)		;OPEN FOR INPUT?
	BNE	40$			;YES
	BIT	#OPN.OU,4(R0)		;OPEN FOR OUTPUT?
	BNE	60$			;YES
40$:	MOVB	#OPNFQ,@#FIRQB+FQFUN	; SET FOR OPEN FOR INPUT
	CALFIP				;DO IT
	CMPB	IOSTS,#NOSUCH		;WAS THE FILE THERE?
	BEQ	50$			;NO
	CALL	ERRCHK			; CHECK FOR ERRORS
	CMP	@#FIRQB+FQDEV,#"LP	; DEVICE LINEPRINTER?
	BEQ	80$			;YES, SO SAY OPENED FOR OUTPUT ONLY
	BIS	#OPN.IN,4(R0)		;SHOW WE OPENED IT FOR INPUT
	BR	OPEN01			;CLEAN UP
50$:	BIT	#OPN.OU,4(R0)		;OPEN FOR OUTPUT IF INPUT FAILS?
	BNE	60$			;YES, SO OK
	BIT	#OPN.IN,4(R0)		;HAVE TO CHECK THIS WAY ALSO
	BEQ	60$			;HE'S OK
	JMP	ERR			;ELSE ERROR
60$:	MOVB	#CREFQ,@#FIRQB+FQFUN	; SET OPEN FOR NORMAL OUTPUT
	CMP	@#FIRQB+FQEXT,@#P.DEXT	; IS THIS OUR COMPILED EXTENSION ?
	BNE	70$			; NOPE SO ALL IS WELL
	MOVB	#CRBFQ,@#FIRQB+FQFUN	; CHANGE THE FUNCTION PLEASE
70$:	CALFIP				;OPEN FILE
	CALL	ERRCHK			; CHECK FOR ERRORS
80$:	BIS	#400,R1			;SHOW WRITE ONLY FILE
	BIS	#OPN.OU,4(R0)		;SHOW OPENED FOR OUTPUT

	GLOBAL	<NOSUCH,EOF,PRVIOL,DTOOOF>
OPEN01:	BIS	R3,OPNFLG		;SHOW THIS CHANNEL IS OPEN
	MOV	2(R0),R2		;GET POINTER TO ALGOL FIB
	BIS	#100000,2(R2)		;SET OPEN BIT
	MOV	4(R2),R2		;GET POINTER TO RSTS FIB
	CMP	@#FIRQB+FQDEV,#"KB	; DID WE JUST OPEN A KEYBOARD?
	BNE	10$			;NO
	BIS	#2,R1			;YES, SET SPECIAL KEYBOARD BIT
10$:	MOV	R1,(R2)+		;SET KIND
	MOV	@#FIRQB+FQBUFL,R0 	; THIS IS THE BUFFER SIZE
	MOV	R0,(R2)+		;PUT IT IN THE FIB
	MOV	#M.FIB,R1		;AND WE WANT IT SAVED
	CALLX	GETSPC			; NOW MAKE A BUFFER
	TST	(R0)+			;AND POINT AT DATA AREA
	MOV	R0,(R2)+		;POINTER TO THE BUFFER WE GOT
	MOV	R4,(R2)+		;CHANNEL NUMBER TIMES 2
	CLR	(R2)+			;CLEAR RECORD NUMBER IF BINARY; NUMBER IN BUFFER IF ASCII
	BIT	#1,-12(R2)		;BINARY FILE?
	BEQ	20$			;YES
	MOV	-6(R2),(R2)		;SET POINTER TO START OF BUFFER
	BR	30$			;THAT'S ALL
20$:	CLR	(R2)			;BUFFER NOT DIRTY
30$:	JMP	DONE			;AND WE ARE DONE

;+
;	RUN 'OPEN'
;-

RUNOPN:	CALL	SETFQB			; SET IT UP
	MOV	#100000,R3		; JUST TO MAKE SURE
	BIS	#1,4(R0)		; SAY WE OPENED IT FOR READ
	MOV	#15.+15.,R4		; CHANNEL NUMBER * 2
	MOV	#512.,@#FIRQB+FQBUFL	; THIS IS THE BUFFER SIZE OF A DISK
	CLR	@#FIRQB+FQDEV		; JUST TO MAKE SURE
	BR	OPEN01			; GO DO COMMON CODE
.SBTTL	CLOSE AN OPEN CHANNEL

CLOSE:	CALL	IO.1			; SET UP SOME POINTERS
	MOV	6(R1),@#FIRQB+FQFIL	;SET CHANNEL NUMBER FOR CLOSE
	BIT	#1,(R1)			;BINARY?
	BNE	10$			;NO
	BIT	#1,12(R1)		;DIRTY?
	BEQ	50$			;NO
	CALL	SETXRB			; SET UP THE XRB
	MOV	10(R1),XRB+XRBLK	; SET RSTS RECORD NUMBER TO WRITE
	BR	40$			;GO TO IT
10$:	BIT	#400,(R1)		;ASCII OUTPUT?
	BEQ	50$			;NO
	CMP	2(R1),#510.		;CHARACTER ORIENTED DEVICE?
	BLT	50$			;YES
	MOV	2(R1),R3		;RECORD LENGTH
	SUB	10(R1),R3		;MINUS NUMBER IN BUFFER
	BEQ	30$			;NOTHING TO DO
	MOV	4(R1),R4		;POINTER TO RSTS BUFFER
	ADD	10(R1),R4		;NOW POINTS TO NEXT SPACE (TO NULL)
20$:	CLRB	(R4)+			;NULL IT OUT
	SOB	R3,20$			;TILL END OF BUFFER
30$:	CALL	SETXRB			; SET UP THE XRB
40$:	.WRITE				;WRITE OUT LAST BUFFER
	CALL	ERRCHK			; CHECK FOR ERRORS
50$:	MOVB	#CLSFQ,@#FIRQB+FQFUN	; SET FOR CLOSE
	CALFIP				;DO IT
	CALL	ERRCHK			; CHECK FOR ERRORS
	BIC	#100000,2(R0)		;SAY FILE IS NOW CLOSED
	MOV	4(R1),R0		;STORE CORE BUFFER POINTER HERE
	SUB	#10,R0			;BACK UP 10 (HOSLER'S SCREWY)
	CLR	(R0)			;SAY MEMORY NOT IN USE
	CALLX	FORGET			; FOR FORGETTING MEMORY ???
	MOV	#1,R3			;GET READY TO UPDATE OPNFLG
	MOV	@#FIRQB+FQFIL,R2	;GET CHANNEL NUMBER TIMES 2
	ROR	R2			;NOW TIMES 1
	ASH	R2,R3			;MAKE A CHANNEL BIT
	BIC	R3,OPNFLG		;CLEAR IT
	JMP	DONE			;THAT'S IT
.SBTTL	READ A FILE

READ:	CALL	IO.1			; SET UP POINTERS
	BIT	#1,(R1)			;BINARY FILE?
	BEQ	BINARY			;GO TO BINARY ROUTINE
	BIT	#400,(R1)		;READ/WRITE BIT
	BEQ	10$			;WAS READ, SO ALL IS OK
	BIT	#2,(R1)			;KEYBOARD?
	BNE	10$			;YES, SO OK
	MOV	#PRVIOL,IOSTS		;ELSE TRYING TO READ A WRITE ONLY FILE
	JMP	ERR			;WHICH IS A PROTECTION VIOLATION
10$:	CALL	IO.2			; SET UP POINTERS AND STUFF
	BIT	#10,(R1)		;LAST OPERATION WRITE?
	BEQ	20$			;NO
	MOV	4(R1),R3		;YES - RESET BUFFER POINTER
	CLR	R4			;    - AND BYTE COUNT
	BIC	#10,(R1)		;CLEAR WRITE INDICATOR
20$:	BIS	#4,(R1)			;SAY READ
30$:	TST	R4			;NUMBER LEFT IN INPUT BUFFER
	BNE	40$			;MORE TO DO
	CALL	SETXRB			; ELSE GET SET FOR TRANSFER
	CLR	XRB+XRBC		;BYTE COUNT
	.READ				;READ A FILE
	CMPB	IOSTS,#EOF		;END OF FILE?
	BEQ	EOFL			;YEP
	CALL	ERRCHK			; CHECK FOR OTHER ERRORS
	MOV	XRB+XRBC,R4		;NUMBER CHARACTERS READ
	MOV	4(R1),R3		;POINTER TO INPUT BUFFER
40$:	DEC	R4			;SAY ONE LESS CHARACTER TO TRANSFER
	MOVB	(R3)+,(R2)		;MOVE ONE
	BEQ	30$			;IGNORE NULLS
	CMPB	(R2),#LF		;LINE FEED?
	BEQ	DONEIO			;YES, TERMINATOR
	CMPB	(R2),#FF		;FORM FEED?
	BEQ	DONEIO			;YES, TERMINATOR
	CMP	R0,#1			;LAST SLOT IN OUTPUT BUFFER?
	BEQ	30$			;YES, OVERWRITE UNTIL TERMINATOR
	DEC	R0			;DECREMENT TRANSFER COUNT
	INC	R2			;INCREMENT BUFFER POINTER
	BR	30$			;READ MORE CHARACTERS
DONEIO:	MOV	R4,10(R1)		;SAVE NUMBER CHARACTER LEFT IN BUFFER FOR NEXT TIME
	MOV	R3,12(R1)		;SAVE POINTER TO WHERE WE'RE AT IN THE BUFFER
DONEB:	MOV	@#PRT,R3		;GET POINTER TO PRT
	BIC	#1,40(R3)		;SAY I/O WAS SUCCESSFUL
DONE:	MOV	R4SAVE,R4		;RESTORE R4
	MOV	(SP)+,R4SAVE		;RESTORE OLD R4
	MOV	(SP)+,R3		;RESTORE R3
	MOV	(SP)+,R2		;RESTORE R2
	MOV	(SP)+,R1		;RESTORE R1
	MOV	(SP)+,R0		;RESTORE R0
	CLR	IOSTS			;CLEAR ANY RECOVERABLE ERRORS
	RTS	PC			;AND RETURN
EOFL:	MOV	@#PRT,R3		;GET POINTER TO PRT
	BIT	#1,40(R3)		;ON ERROR GO TO SET?
	BNE	DONE			;YEP, SO JUST RETURN
	JMP	ERRCHK			;ELSE ERROR
BINARY:	MOV	@SYS.FD,R2		;GET RECORD LENGTH AND KIND
	CLC				;DON'T WANT CARRY ROARING IN
	ROR	R2			;ONE BIT OF KIND GONE
	ASR	R2			;TWO BITS OF KIND GONE
	ASR	R2			;ALL OF KIND IS GONE
	MOV	R2,-(SP)		;WE NEED RECORD LENGTH LATER
	MOV	SYS.RN,R3		;POSSIBLE RECORD NUMBER TO READ/WRITE
	BGE	10$			;WAS REAL
	MOV	2(R0),R3		;HE WANTED TO USE HIS CURRENT RECORD NUMBER
	BIC	#100000,R3		;YOU DON'T WANT THE OPEN BIT DO YOU?
	INC	R3			;POINT TO LOGICAL RECORD TO GET
10$:	MOV	R3,-(SP)		;WE NEED THIS LATER ALSO
	MOV	SYS.CT,R3		;NUMBER OF BYTES TO TRANSFER
	DEC	R3			;DECREMENT IT
	CLR	R2			;MSW FOR DIV
	DIV	2(SP),R2		;(TRANSFER COUNT - 1)/LOGICAL RECORD LENGTH
	ADD	(SP),R2			;ADD OLD CURRENT LOGICAL RECORD NUMBER
	BIS	#100000,R2		;WE WANT IT TO BE OPEN, DON'T WE?
	MOV	R2,2(R0)		;PUT IT WHERE IT BELONGS
	MOV	(SP)+,R3		;GET BACK CURRENT LOGICAL RECORD NUMBER
	MOV	(SP)+,R2		;AND LOGICAL RECORD LENGTH
	MUL	R3,R2			;WORD POINTER TO BEGINNING OF LOGICAL BLOCK IN FILE
	DIV	#512.,R2		;R2 = RSTS RECORD,  R3 = BYTE IN THAT RECORD
20$:	INC	R2			;RSTS NUMBERS BLOCK STARTING AT ONE
	ADD	4(R1),R3		;ABSOLUTE BUFFER POINTER
	MOV	SYS.CT,R4		;TRANSFER COUNT IN BYTES
	MOV	SYS.CA,R0		;CORE ADDRESS TO TRANSFER TO/FROM
	MOV	4(R1),-(SP)		;POINTER TO RSTS BUFFER
	ADD	#512.,(SP)		;NOW POINTS TO END OF RSTS BUFFER
	CMP	R2,10(R1)		;DO WE ALREADY HAVE THIS RECORD?
	BEQ	60$			;YES
30$:	BIT	#1,12(R1)		;DIRTY?
	BEQ	40$			;NO
	CALL	SETXRB			; ELSE PREPARE TO WRITE IT OUT
	MOV	10(R1),XRB+XRBLK	; RECORD TO WRITE
	.WRITE				;WRITE IT
	CALL	ERRCHK			; CHECK FOR ERRORS
	DEC	12(R1)			;IT'S NOT DIRTY NOW!
40$:	MOV	R2,10(R1)		;SET REAL RECORD NUMBER TO THE ONE WE GOT
	CALL	SETXRB			; SET UP XRB
	MOV	R2,@#XRB+XRBLK		;SET REAL RECORD NUMBER TO GET
	CLR	XRB+XRBC		;CLEAR BYTE COUNT
	.READ				;READ REAL BLOCK
	CMPB	IOSTS,#EOF		;END OF FILE ON DEVICE?
	BNE	50$			;NO
	TST	SYS.IO			;IS THIS A WRITE?
	BEQ	EOFL			;NO, GO TO EOF HANDLER
	BR	60$			;SKIP ERROR CHECK
50$:	CALL	ERRCHK			; CHECK FOR OTHER ERRORS
60$:	TST	SYS.IO			;WRITING?
	BEQ	70$			;NO, NOT DIRTYING BUFFER
	BIS	#1,12(R1)		;DIRT IS IN THE BUFFER
70$:	TST	R4			;ALL DONE?
	BEQ	120$			;YEP
80$:	TST	SYS.IO			;READING OR WRITING?
	BEQ	90$			;READING
	MOVB	(R0)+,(R3)+		;MOVE A BYTE THIS WAY
	BR	100$			;AND SKIP AROUND
90$:	MOVB	(R3)+,(R0)+		;MOVE A BYTE THAT WAY
100$:	CMP	R3,(SP)			;END OF BUFFER ON DEVICE?
	BNE	110$			;NOPE, KEEP GOING
	INC	R2			;RSTS REAL RECORD NUMBER
	MOV	4(R1),R3		;RESET RSTS BUFFER POINTER
	DEC	R4			;WE WOULDN'T WANT TO BE OFF BY A WORD WOULD WE?
	BR	30$			;GO DO SHIT
110$:	SOB	R4,80$			;DECREMENT BYTE COUNT AND CONTINUE UNTIL DONE
120$:	TST	(SP)+			;DUMP END OF BUFFER POINTER
	JMP	DONEB			;AND DONE
.SBTTL	WRITE A FILE

WRITE:	CALL	IO.1			; SET UP POINTERS
	BIT	#1,(R1)			;BINARY?
	BEQ	BINARY			;CALL ON BINARY ROUTINE
	BIT	#2,(R1)			;IS THIS THE KEYBOARD?
	BNE	10$			;YES, SO ANYTHING GOES
	BIT	#400,(R1)		;WRITTING ON A READ ONLY FILE?
	BNE	10$			;NO, SO OK
	MOVB	#PRVIOL,IOSTS		;TOO BAD, PROTECTION VIOLATION
	JMP	ERR			;GIVE IT TO HIM
10$:	CALL	IO.2			; SET UP POINTERS AND STUFF
	BIT	#4,(R1)			;LAST OPERATION READ?
	BEQ	20$			;NO
	MOV	4(R1),R3		;YES - RESET BUFFER POINTER
	CLR	R4			;    - AND BYTE COUNT
	BIC	#4,(R1)			;CLEAR READ INDICATOR
20$:	BIS	#10,(R1)		;SAY WRITE
30$:	TST	R0			;ANYTHING THERE?
	BEQ	40$			;NO, SO FINISH UP
	MOVB	(R2)+,(R3)+		;MOVE A CHARACTER
	INC	R4			;COUNT IT
	DEC	R0			;COUNT IT HERE ALSO
	CMP	R4,2(R1)		;WRITTEN ENOUGH?
	BNE	30$			;NOPE
	CALL	WRITE1			; WRITE THE BUFFER
	BR	30$			;AND AROUND AND AROUND
40$:	CMP	2(R1),#510.		;CHARACTER ORIENTED DEVICE?
	BGE	50$			;NO, SO WE'RE DONE
	CALL	WRITE1			; ELSE HAVE TO WRITE OUT REST OF BUFF
50$:	JMP	DONEIO			;AND WE'RE DONE
.SBTTL	DELETE A FILE

DELETE:	CALL	SETFQB			; SET UP FIRQB
	MOVB	#DLNFQ,FIRQB+FQFUN	; SET FOR DELETE
	CALFIP				;KILL IT
	CMPB	@#IOSTS,#NOSUCH		;CAN'T FIND FILE OR ACCOUNT?
	BEQ	10$			;YES, NOT AN ERROR WITH ALGOL
	CALL	ERRCHK			; CHECK FOR ERRORS
10$:	JMP	DONE			;AND DONE


.SBTTL	GET STATUS

STATUS:	CALL	SETFQB			; SET UP FIRQB
	CLR	R0			;CLEAR ANSWER
	MOVB	#LOKFQ,FIRQB+FQFUN	; SET FOR LOOK-UP BY FILE NAME
	CLR	@#FIRQB+FQERNO		;SAY NOT WILD-CARD TYPE LOOKUP
	CALFIP				;DO IT
	CMPB	@#IOSTS,#NOSUCH		;CAN'T FIND FILE OR ACCOUNT?
	BEQ	10$			;YEP
	CALL	ERRCHK			; CHECK FOR ANY OTHERS
	MOV	#1,R0			;RETURN A 1 FOR PRESENT
10$:	MOV	R4SAVE,R4		;RESTORE R4
	MOV	(SP)+,R4SAVE		;RESTORE OLD R4
	MOV	(SP)+,R3		;RESTORE R3
	MOV	(SP)+,R2		;RESTORE R2
	MOV	(SP)+,R1		;RESTORE R1
	MOV	(SP),-(SP)		;SAVE SAVED R0
	MOV	4(SP),2(SP)		;MOVE UP RETURN ADDRESS
	MOV	R0,4(SP)		;PUT ANSWER ON WHAT WILL BE TOP OF STACK
	MOV	(SP)+,R0		;RESTORE R0
	RTS	PC			;AND RETURN TO HOSLER
.SBTTL	SET UP THE XRB

;CALL:	JSR	PC,SETXRB
; R1 = RSTS FIB
;
;RETURN:
; XRB IS SET FROM THE RSTS FIB.  BYTE COUNT IS SET TO BUFFER LENGTH.
; RECORD IS SET TO ZERO.  NOTHING IS DESTROYED.

SETXRB:	MOV	R0,-(SP)		;SAVE R0
	MOV	R1,-(SP)		;SAVE R1
	TST	(R1)+			;SKIP READ/WRITE BITS
	MOV	#XRB,R0			;GET XRB POINTER
	MOV	(R1),(R0)+		;LENGTH OF I/O BUFFER
	MOV	(R1)+,(R0)+		;BYTE COUNT
	MOV	(R1)+,(R0)+		;POINTER TO BUFFER START
	MOV	(R1)+,(R0)+		;CHANNEL NUMBER
	CLR	(R0)+			;BLOCK NUMBER
	CLR	(R0)+			;TITTY WAIT TIME
	MOV	(SP)+,R1		;RESTORE R1
	MOV	(SP)+,R0		;RESTORE R0
	RTS	PC			;AND RETURN
.SBTTL	SET UP THE FIRQB

;CALL:	JSR	PC,SETFQB
;
;RETURN:
; R0 = POINTER TO FILE DESCRIPTOR
; R1 = FILE TYPE
; R2 IS DESTROYED
; R3 IS DESTROYED
; R4 IS DESTROYED

SETFQB:	CALL	CLRFQB			; CLEAR OT THE FIRQB
	MOV	SYS.FD,R0		;GET ADDRESS OF FILE DESCRIPTOR
	MOV	(R0),R1			;MAXIMUM RECORD NUMBER AND FILE TYPE
	BIC	#^C<7>,R1		;NOW JUST FILE TYPE
	MOV	2(R0),R3		;GET POINTER TO ALGOL FIB
	ADD	#6,R3			;POINTS TO FILENAME (ASCII) NOW
	CMP	R1,#1			;TEST FOR DISK FILE
	BLE	30$			;YES, IT IS
	CMP	R1,#3			;TEST FOR TERMINAL
	BLE	10$			;YES, IT IS
	MOV	#"LP,(R3)+		;STICK IN THE TITLE
	BR	20$			;AND MERGE
10$:	MOV	#"KB,(R3)+		;STICK IN THE TITLE
20$:	MOV	#':,(R3)		;AND REALLY MAKE A TITLE
	TST	-(R3)			;BACK UP THE POINTER
	MOV	#1,R1			;MARK IT ASCII
30$:	CALLX	CSI			; SCAN IT
	CALL	ERRCHK			; NOW CHECK FOR ERRORS
	RTS	PC			;RETURN
.SBTTL	CLEAR OUT THE FIRQB

;CALL:	JSR	PC,CLRFQB
;
;RETURN:
; THE FOLLOWING ARE CLEARED IN THE FIRQB:
;   FILESIZE, RECORDSIZE, MODE, FILE FLAG,
;   CLUSTERSIZE, INDEX FOR DIRECTORY LOOKUPS.

CLRFQB:	CLR	FIRQB+FQSIZ		;FILE SIZE
	CLR	FIRQB+FQBUFL		;RECORD SIZE
	CLR	FIRQB+FQMODE		;MODE
	CLR	FIRQB+FQFLAG		;FILE FLAG
	CLR	FIRQB+FQCLUS		;CLUSTER SIZE
	CLR	FIRQB+FQNENT		;INDEX FOR DIRECTORY LOOKUPS
	RTS	PC
.SBTTL	SET UP POINTERS TO ALGOL AND RSTS FIBS

;CALL:	JSR	PC,IO.1
;
;RETURN:
; R0 = POINTER TO ALGOL FIB
; R1 = POINTER TO RSTS FIB

IO.1:	MOV	SYS.FD,R0		;POINTER TO FILE DESCRIPTOR
	MOV	2(R0),R0		;POINTER TO ALGOL FIB
	MOV	4(R0),R1		;POINTER TO RSTS FIB
	RTS	PC			;THAT'S ALL


.SBTTL	SET UP POINTERS AND STUFF

;CALL:	JSR	PC,IO.2
; R1 = POINTER TO RSTS FIB
;
;RETURN:
; R0 = TRANSFER COUNT
; R2 = POINTER TO CORE BUFFER
; R3 = POINTER INTO RSTS BUFFER (SAVED FROM LAST TIME)
; R4 = NUMBER CHARACTERS LEFT IN RSTS BUFFER (FROM LAST TIME)

IO.2:	MOV	SYS.CT,R0		;TRANSFER COUNT
	MOV	SYS.CA,R2		;POINTER TO CORE BUFFER
	MOV	12(R1),R3		;POINTER INTO RSTS BUFFER (SAVED FROM LAST TIME)
	MOV	10(R1),R4		;NUMBER CHARACTER LEFT IN RSTS BUFFER (FROM LAST TIME)
	RTS	PC			;RETURN
.SBTTL	WRITE OUT A BLOCK

;CALL:	JSR	PC,WRITE1
; R1 = POINTER TO RSTS FIB
; R4 = BYTE COUNT
;
;RETURN:
; R3 = POINTER TO RSTS BUFFER
; R4 = ZERO (BYTE COUNT RESET)

WRITE1:	CALL	SETXRB			; SET UP XRB
	MOV	R4,XRB+XRBC		;BYTE COUNT
	BEQ	10$			;DON'T DO THE WRITE IF NOTHING THERE
	.WRITE				;WRITE IT
	CALL	ERRCHK			; CHECK FOR OTHER ERRORS
10$:	MOV	4(R1),R3		;RESET BUFFER POINTER
	CLR	R4			;RESET BYTE COUNT
	RTS	PC			;AND RETURN
.SBTTL	ERROR CHECKER

;CALL:	JSR	PC,ERRCHK
;
;RETURN:
; IF IT RETURNS THEN THERE WERE NO ERRORS ELSE IT WON'T RETURN.

	.ENABL	LSB
ERRCHK:	TST	IOSTS			;ERRORS...?
	BNE	10$			;YEP
	RTS	PC			;NOPE

10$:	MOV	R4SAVE,R4		;R4 MUST BE RIGHT
	MOV	SYS.FD,R0		;GET FILE DESCRIPTOR
	MOV	2(R0),R1		;POINT TO ALGOL FIB
	ADD	#6,R1			;MOVE UP TO TITLE
	MOV	#IOBUFF,R2		;GET A BUFFER POINTER
20$:	MOVB	(R1)+,(R2)+		;MOVE A CHARACTER
	BNE	20$			;UNTIL ALL DONE
	MOVB	#40,-1(R2)		;CHANGE NULL TO SPACE
	MOVB	#'-,(R2)+		;PUT IN ONE OF THOSE
	MOVB	#40,(R2)+		;AND ANOTHER SPACE
	BR	30$			;AND REJOIN

;	*** NOBODY COMES HERE ***

CTRLC:	.TTRST				;NEED THE ECHO ON
	MOV	#IOBUFF,R2		;GET THE BUFFER POINTER
	MOV	#60$,R1			;AND THE MESSAGE POINTER
	BR	40$			;AND GO MOVE IT
ERR::	MOV	#IOBUFF,R2		;GET THE BUFFER POINTER
30$:	MOV	#FIRQB+FQFUN,R1		;GET A FIRQB POINTER
	MOVB	#ERRFQ,(R1)+		;STICK IN THE FIP CODE
	MOVB	IOSTS,(R1)		;AND THE ERROR CODE
	CALFIP				;GET'ER
	TST	IOSTS			;GET AN ERROR ON THAT?
	BNE	50$			;WHAT WAS THAT???
40$:	MOVB	(R1)+,(R2)+		;MOVE A BYTE OF MESSAGE
	BNE	40$			;UNTIL WE GET EM ALL
	MOV	#IOBUFF,R2		;RESET BUFFER POINTER
	JMPX	ERROR			;NOW GO PRINT IT
50$:	JMP	EXIT			;GET OUT THE FAST WAY
60$:	.ASCIZ	/** User Abort **/
	.DSABL	LSB
	.EVEN
	.SBTTL	BAD ERROR TRAPS
;+
;	NEEDED TO DEBUG MM ERRORS
;-

;+
;	PRINT A CHARACTER IN R5
;-

CHROUT::MOV	R5,-(SP)		; SAVE R5 PLEASE
	CALL	CLRXRB			; I HOPE THIS WORKS
	MOV	#XRB+XRLEN,R5		; SET POINTER
	MOV	#1,(R5)			; ONE CHARACTER PLEASE
	MOV	(R5)+,(R5)+		; DUP IT
	MOV	SP,(R5)+		; FROM THE STACK
	.WRITE				; DO IT
	MOV	(SP)+,R5		; AND RESTORE IT
	RTS	PC			; THAT'S ALL

;+
;	PRINT A NUMBER IN R2
;

NUMOUT::MOV	R2,-(SP)		; SAVE R2
	MOV	R5,-(SP)		; AND R5
	MOV	#30,R5			; SET IT UP
	SEC				; MORE SET UP
N1:	ROL	R2			; MAGIC OUTPUT ROUTINE
	ROLB	R5			; F.M.
	CALL	CHROUT			; PRINT IT
N2:	MOV	#206,R5			; MORE MAGIC
10$:	ASL	R2			; STILL MORE
	BEQ	20$			; DONE YET ???
	ROLB	R5			; NOPE
	BCS	10$			; WHICH BRANCH
	BR	N1			; THIS ONE
20$:	MOV	(SP)+,R5		; ALL DONE
	MOV	(SP)+,R2		; THIS TOO
	RTS	PC			; THAT'S IT

;+
;	BAD ERRORS COME HERE
;-

ERRBAD::MOV	(SP)+,R2		; GET PC PLEASE
	TST	(SP)+			; AND DUMP PS
	MOV	@#IOSTS,-(SP)		; SAVE ERROR
	CALL	NUMOUT			; PRINT IT
	MOV	(SP)+,@#IOSTS		; RESTORE ERROR
	JMP	ERR			; SO WE KNOW WHAT IT IS
	.SBTTL	CLEAR XRB
;+
;	CLEAR XRB
;-

CLRXRB::MOV	R0,-(SP)		; SAVE ONE
	MOV	#XRB+XRBSIZ,R0		; SET IN IT'S SIZE
10$:	CLR	-(R0)			; CLEAR IT OUT CLEM
	CMP	R0,#XRB			; ARE WE DONE ?
	BHI	10$			; NOPE
	MOV	(SP)+,R0		; RESTORE R0
	RTS	PC			; ALL DONE

	.END

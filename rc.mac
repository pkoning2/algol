TITLE	RC,<ALGOL RUNTIME SUPPORT/INTERPRETER>,08,06-SEP-80,TG/GPK

;	ENTRY POINTS TO THIS MODULE:

;+
; INTERP	- MAIN INTERPRETER
; SBR		- JUMP FROM INIT
; STEST		-
;-

;	ROUTINES CALLED FROM THIS MODULE:
.GLOBL	COM02,COM03,COM04,COM05,COM06
.GLOBL	COM07,COM10,COM11,COM12,COM13
.GLOBL	COM14,ERROR,GETIT,INDEX,FORGET
.GLOBL	GETARY,RETDSK,SYSTEM,ALLOC1
.GLOBL	ALLOC2,ALLOCS

	ORG	RC
.SBTTL	OPERATOR DISPATCH TABLE
;	THIS TABLE CONTAINS THE ADDRESSES OF THE ROUTINES
;	WHICH CAN BE CALLED AS OPERATORS UNDER THE ALGOL
;	SYSTEM.  THE ORDER HERE HAD BETTER CORRESPOND TO
;	THAT USED IN THE COMPILER!!!

	ORG	OPTBL

	IADD				;INTEGER ADD
	AOC				;ARRAY OPERAND CALL
	ASD				;ARRAY STORE DESTRUCTIVE
	ASN				;ARRAY STORE NON-DESTRUCTIVE
	BRUN				;BRANCH NON-CONDITIONAL
	BRTR				;BRANCH ON TRUE CONDITION
	BRFL				;BRANCH ON FALSE CONDITION
	ENTR				;ENTER BLOCK
	CHS				;CHANGE SIGN
	COMM				;TALK TO THE MCP
	DEL				;DELETE TOP OF STACK
	IDIV				;INTEGER DIVIDE
	DUP				;DUPLICATE TOP OF STACK
	NEQ				;NOT EQUAL COMPARE
	EQL				;EQUAL COMPARE	
	GEQ				;GREATER THAN OR EQUAL COMPARE
	LSS				;LESS THAN COMPARE
	GTR				;GREATER THEN THOU COMPARE
	LEQ				;LESS THAN OR EQUAL COMPARE
	LOD				;LOAD
	LOR				;LOGICAL OR
	LND				;LOGICAL AND
	MKS				;MARK STACK
	REP				;REPLACE
	IMUL				;INTEGER MULTIPLY
	LNG				;LOGICAL NEGATE
	REL				;RELEASE
	RTN				;RETURN
	SAV				;SAVE
	SBR				;SUBROUTINE
	SHL				;SHIFT LEFT
	SHR				;SHIFT RIGHT
	STOD				;STORE DESTRUCTIVE
	STON				;STORE NON-DESTRUCTIVE
	ISUB				;INTEGER SUBTRACT
	XCH				;EXCHANGE
	SCAN				;SCAN
	IMOD				;MOD FUNCTION
	XADC				;ARRAY DESCRIPTOR CALL
	FDI				;FIELD ISOLATE
	BPS				;BUMP STACK POINTER
	SWP				;SWAP TWO ARRAYS
	EXP				;EXPONENTIATE
	FID				;FIELD ISOLATE DYNAMIC
	RSDN				;ROTATE STACK DOWN
	RSUP				;ROTATE STACK UP
	INOP				;IN TRUTHSET TEST
	OCX				;OCCURS INDEX (FOR CASES)
	LODB				;LOAD BYTE OPERATOR
	IDIVT				;INTEGER DIVIDE TRUNCATE
	FISO				;FIELD ISOLATE
	FISD				;FIELD ISOLADE DYNAMIC
	FIND				;FIND RCW FOR ADDRESSING
	ONES				;COUNT # OF BITS ON
	FONE				;GET LEFT MOST BIT THATS ON
	B1D				;BUILD 1-DIMENSIONAL ARRAY DESCRIPTOR
	B2D				;"" BUT 2-DIM
	DPL				;DUPLICATE ARRAY DESC AND LOAD
	BLD				;BUILD ARRAY
	PLOAD				;LOAD WHAT POINTER POINTS TO
	PART				;PARTIAL WORD
	PSTN				;POINTER STORE NON-DESTRUCTIVE
	PSTD				;POINTER STORE DESTRUCTIVE
	SCMP				;STRING COMPARE
	PLNK				;LINK POINTERS

	DPT	=	OPTBL-1200
.SBTTL	LODB, FIND ROUTINES

;
;	LOAD BYTE OPERATOR
;
	ORG	RC
LODB:	MOVB	@(SP)+,-(SP)		;LOAD BYTE THAT TOS POINTS TO
	CLRB	1(SP)			;AND CLEAR UPPER BYTE
	JMP	INTERP			;AND EXIT

;
;	F I N D
;	FIND IS USED FOR ACCESSING IDENTIFIERS GLOBAL TO ONE PROC AND LOCAL
;	TO ANOTHER.
;	1ST WORD  (TOS)	- LEVEL OF PROC IDENTIFIER DECLARED IN
;	2ND WORD	- OFFSET FROM RCW.
;
;	WE DO A STACK SEARCH TO FIND THE IDENTIFIER
;
FIND:	MOV	(SP)+,R1		;GET LEVEL
	MOV	R4,R0			;GET CURRENT RCW
10$:	CMP	-10(R0),R1		;SEE IF IN THE PROPER LEVEL YET
	BLE	20$			;YES
	MOV	(R0),R0			;NO, GET NEXT RCW
	BR	10$
20$:	ADD	R0,(SP)			;ADD ADDRESS OF RCW TO OFFSET FOR ADDRESS
	JMP	INTERP			;EXIT
.SBTTL	EQL, NEQ, GTR, GEQ, LSS, LEQ, SHR, SHL ROUTINES
;
;		R E L A T I O N A L	O P E R A T O R S
;
;	THESE OPERATORS RELATE BETWEEN THEMSELVES AND THE TOP TWO OPERANDS
;	ON STACK PRODUCING A RESULT OF EITHER 0 (FALSE) OR 1 (TRUE)
;	FROM 2(SP) ROP (SP)
;
	.ENABL	LSB
EQL:	CMP	(SP)+,(SP)+		;EQUAL TEST
	BEQ	20$
	BR	10$
NEQ:	CMP	(SP)+,(SP)+		;NOT EQUAL TEST
	BNE	20$
	BR	10$
GTR:	CMP	(SP)+,(SP)+		;GREATER THAN TEST
	BLT	20$
	BR	10$
GEQ:	CMP	(SP)+,(SP)+		;GREATER THAN OR EQUAL TEST
	BLE	20$
	BR	10$
LSS:	CMP	(SP)+,(SP)+		;LESS THAN TEST
	BGT	20$
	BR	10$
LEQ:	CMP	(SP)+,(SP)+		;LESS THAN OR EQUAL TEST
	BGE	20$
;	BR	10$			;
10$:	CLR	-(SP)			;RESULT IS FALSE
	JMP	INTERP
20$:	MOV	#1,-(SP)		;RESULT IS TRUE
	JMP	INTERP
	.DSABL	LSB
;
;		S H I F T    O P E R A T O R S
;
;	1ST WORD (TOS) IS # OF BITS TO SHIFT
;	2ND WORD IS VALUE TO BE SHIFTED
;
SHR:	NEG	(SP)			;HAVE TO NEGATE TOS FOR RIGHT SHIFT
SHL:	MOV	(SP)+,R2
	MOV	(SP)+,R1		;SHIFT LEFT ENTERS HERE BECAUSE TOS IS ALL SET
	ASH	R2,R1			;NOW SHIFT A FEW BITS
	MOV	R1,-(SP)		;PUSH ANSWER
	JMP	INTERP
.SBTTL	INOP, PART ROUTINES
;
;		T R U T H S E T   S E T   T E S T I N G
;	THE IN OPERATOR TESTS TO SEE IF A VALUE IS IN A PARTICULAR TRUTHSET
;	1ST WORD  (TOS)	- ADDRESS OF 1ST ELEMENT OF TRUTHSET
;	2ND WORD	- VALUE WE ARE TESTING
INOP:	MOV	#INTERP,-(SP)		;TRUTHSET TESTS ALSO NEEDED BY OTHER ROUTINES
IN:	MOV	(SP)+,R2		;SAVE RETURN ADDRESS
	MOV	(SP)+,R0		;GET ADDRESS OF TRUTHSET
	MOV	(SP),R1			;GET VALUE
	CLR	(SP)			;INITIALIZE BOOLEAN TO FALSE
	MOV	R2,-(SP)		;PUT RETURN ADDRESS BACK ON STACK
	BIT	#177600,R1		;SEE IF TOO BIG OR TOO SMALL
	BNE	10$			;YES
	MOV	R1,R2			;DUP A COPY TO WORK WITH
	ASH	#-3,R1			;OPTIMIZE FOR 45'S & 50'S
	BIC	#1,R1			;AND CLEAR BOTTOM BIT (WORD INDEX)
	ADD	R1,R0			;ADDRESS OF WORD IN TRUTHSET
	MOV	#1,R1			;BIT TO BE MOVED TO LEFT
	BIC	#177760,R2		;MOD BY 16
	ASH	R2,R1			;SHIFT BIT TO PROPER PLACE
	BIT	R1,(R0)			;SEE IF ENTRY IN TRUTHSET IS ON
	BEQ	10$			;NOT ON
	INC	2(SP)			;MAKE ENTRY TRUE
10$:	RTS	PC			;RETURN TO CALLER

;
;		P A R T I A L   W O R D S
;
PART:	MOV	(SP)+,R2		;# OF BITS
	BMI	INVOP			;MUST BE POS
	MOV	(SP)+,R1		;LEFT MOST BIT #
	BMI	INVOP			;ALSO MUST BE >0
	CMP	#20,R2			;SEE IF TO BIG
	BLT	INVOP			;YEP
	CMP	#20,R1			;HERE TO
	BLE	INVOP
	MOV	R1,R0			;SAVE IT
10$:	INC	R0			;LINE UP # OF BITS WITH LEFTMOST BIT #
	CMP	R2,R0			;CHECK FOR LINED UP NESS
	BEQ	20$
	BIC	#177760,R0		;MOD 16.
	CMP	#77777,(SP)		;SET CARRY TO SAME AS BIT #15
	ROL	(SP)			;PULL INTO BIT #0
	BR	10$
20$:	MOV	#-1,R0			;MASK OF WHICH BITS TO CLEAR
	ASH	R2,R0			;SHIFT BIT
	BIC	R0,(SP)			;CLEAR OUT THE UNWANTED BITS
	JMP	INTERP
.SBTTL	FISD, FISO ROUTINES
;
;		F I E L D   M A N E U V E R S
;
;	THESE TWO OPERATORS ARE USED FOR THE CONCATENATION OPERATOR
;	THERE ARE TWO FORMS:
;	FISD		& [LEFT-BIT-TO:NUMBER-OF-BITS]
;	FISO		& [LEFT-BIT-TO:LEFT-BIT-FROM:NUMBER-OF-BITS]
;	THE FIELD ISOLATE DYNAMIC IS ASSUMED THAT THE LEFT-BIT-FROM
;	    IS THE SAME AS THE # OF BITS - 1. (AND IS FAKED AS SUCH)
;
;	1ST WORD (TOS)	- # OF BITS
;	2ND WORD	- LEFT-BIT FROM	(FISO ONLY)
;	3RD WORD	- LEFT-BIT TO
;	4TH WORD	- VALUE TO BE STUFFED THERE
;	5TH WORD	- VALUE TO GET STUFFED INTO
;
;	FIELD ISOLATE DYNAMIC
FISD:	MOV	(SP),-(SP)		;DUP THE # OF BITS
	DEC	2(SP)			;LEFT-BIT FROM = # OF BITS - 1
;	FIELD ISOLATE
FISO:	MOVB	#1,RWT5			; SET CONCAT TOG
	CMP	(SP),#20		;SEE IF TOO  BIG
	BGT	INVOP
	MOV	#1,R1			;PUT A 1 INTO R1
	MOV	(SP),R0			;SEE IF NEGATIVE & GET #
	BMI	INVOP			;TOO BAD !
	BEQ	20$			;DONE ALIGNMENT
10$:	ASL	R1			;(I.E. GET 2**R0)
	SOB	R0,10$
20$:	DEC	R1			;MASK OF WHICH BITS ARE GOOD
	MOV	(SP)+,R0		;NUMBER OF BITS
	MOV	(SP),R2			;LEFT-BIT FROM
	BMI	INVOP			;NOT ALLOWED TO BE NEGATIVE
	CMP	R2,#20
	BGE	INVOP			;TOO BIG
30$:	INC	R2			;ALIGN MASK UP WITH LEFT-BIT FROM
	CMP	R0,R2			;WHEN LEFT-BIT FROM = # OF BITS
	BEQ	40$			;THEN WE ARE ALIGHNED
	BIC	#177760,R2		;MOD 16.
	SEC				;ASSUME BIT #0 SET !
	ROR	R1			;PULL BIT #0 TO BIT #15
	BCS	30$			;GOOD GUESS
	BIC	#100000,R1		;WOOPS!
	BR	30$
40$:	MOV	(SP)+,R2		;GET LEFT-BIT FROM
	TST	(SP)			;SEE IF LEFT-BIT TO IS LEGIT
	BMI	INVOP
	CMP	(SP),#20		;TOO BIG?
	BGE	INVOP			;YES
	SUB	(SP)+,R2		;SHIFT COUNT FOR FDI
	NEG	R2			;WE WANT LEFT-BIT-TO - LEFT-BIT-FROM
	BGE	50$			;>=0
	CLR	R2			;DON'T WRAP THIS ONE
50$:	MOV	SP,R0			;NEXT 3 INSTRUCTIONS
	TST	(R0)+			;DUE TO INCOMPATIBILITY
	MOV	R0,-(SP)		;OF 11'S (ADDRESS OF 5TH WORD)
	MOV	R1,-(SP)		;MASK
	MOV	R2,-(SP)		;SHIFT COUNT
	JMP	FDI			;LET FDI TAKE IT FROM HERE
.SBTTL	IADD, ISUB, IMUL, IEXP
;
;	A R I T H M E T I C   O P E R A T O R S
;
;
; THE ARITHEMETIC OPERATORS WORK OVER THE TOP TWO VALUES
; ON THE STACK TO PRODUCE A RESULT WHICH IS LEFT ON THE
; STACK IN PLACE OF THE TWO OPERANDS
;
;	ADD
;
IADD:	ADD	(SP)+,(SP)		;ADD TOP OF STACK, POP, TO TOP OF STACK
	JMP	INTERP
;
;	SUBTRACT
;
ISUB:	SUB	(SP)+,(SP)		;SUBTRACT TOP OF STACK, POP, FROM TOP OF STACK
	JMP	INTERP
;
;	MULTIPLY
;
	.ENABL	LSB
IMUL:	MOV	(SP)+,R0
	MOV	(SP)+,R2
	JSR	PC,10$			;MULTIPLIES R2 BY R0,
	MOV	R1,-(SP)		;LEAVES RESULT IN R1
	JMP	INTERP
10$:	MUL	R2,R0			;DO THE MULTIPLY
	TST	R1			;DO A QUICK CHECK
	SXT	R2			; FOR INTEGER OVERFLOW
	CMP	R0,R2			;THEY SHOULD BE EQUAL
	BNE	20$			;NOPE, GOT A PROBLEM
	RTS	PC			;YEAH, EXIT
20$:	QUIT	<?Integer overflow>
INVOP:	QUIT	<?Invalid operand in code file>
;
;	EXPONENTIATE
;
EXP:	MOV	2(SP),R2		;GET # TO BE RAISED TO POWER
	CLR	R1			;NEGATIVE POWER YIELDS 0 RESULT
	MOV	(SP)+,(SP)		;MOVE POWER
	BMI	40$			;DONE IF NEGATIVE POWER
	INC	R1			;START BY MULTIPLING BY 1
	TST	(SP)			;SEE IF DONE (POWER = 0)
	BEQ	40$
30$:	MOV	R1,R0			;MOVE PREVIOUS ANSWER TO MULTIPLICANDS POSITION
	JSR	PC,10$			;MULTIPLY BY #
	DEC	(SP)			;REDUCE POWER BY ONE
	BNE	30$			;LOOP UNTIL POWER IS 0
40$:	MOV	R1,(SP)			;R1 SHOULD NOW CONTAIN RESULT
	JMP	INTERP
	.DSABL	LSB
.SBTTL	IDIVT, IDIV, IMOD, CHS
;
;	DIVIDE TRUNCATE
;
	.ENABL	LSB
IDIVT:	MOV	(SP)+,R2		;FETCH THE DIVISOR
	MOV	(SP)+,R1		; AND THE DIVIDEND
	JSR	PC,30$			;GET OPERANDS AND DIVIDE
	MOV	R0,-(SP)		;QUOTIENT IS LEFT IN R0
	BR	INTERP
;
;	DIVIDE ROUNDED
;

IDIV:	MOV	(SP)+,R2		;FETCH THE DIVISOR
	MOV	(SP)+,R1		; AND THE DIVIDEND
	JSR	PC,30$			;GET OPERANDS AND DIVIDE
	MOV	R0,-(SP)		;QUOTIENT IS LEFT IN R0
	MOV	R2,R0			;COPY DIVISOR
	ASR	R0			;AND GET HALF OF IT
	CMP	R0,R1			;CHECK IT AGAINST REMAINDER
	BGT	INTERP			;EXIT
10$:	BLT	20$			;ROUND UP
	ROR	R2			;CHECK DIVISOR AGAIN
	BCS	INTERP			;DON'T ROUND
20$:	INC	(SP)			;ROUND
	BR	INTERP			;AND EXIT
;
;	MOD FUNCTION
;

IMOD:	MOV	(SP)+,R2		;FETCH THE DIVISOR
	MOV	(SP)+,R1		; AND THE DIVIDEND
	JSR	PC,30$			;GET OPERAND AND DIVIDE
	MOV	R1,-(SP)		;SAVE REMAINDER
	BR	INTERP
30$:	SXT	R0			;AND EXTEND THE SIGN
	DIV	R2,R0			;DO A DIVIDE
	BCS	40$			;CHECK FOR ZERO DIVIDE
	RTS	PC			;OK, SO EXIT
40$:	QUIT	<?Division by zero>
	.DSABL	LSB
;
;	CHANGE THE SIGN
;

CHS:	NEG	(SP)
	BR	INTERP
.SBTTL	LND, LOR, LNG, STOD, STON, PSTD, PSTN ROUTINES
;
;		L O G I C A L	 O P E R A T O R S
;
;	THESE OPERATORS TAKE THE TOP TWO OPERANDS ON THE STACK
;	AND ANDS OR ORS THEM TOGETHER, WHICHEVER IS MORE APPROPRIATE
;	TO THE SITUATION. LNG DOES A LOGICAL NEGATE ON TOS
;
;	AND
;
LND:	COM	(SP)			;SWITCH STATUS OF BITS TO USE FOR A CLEAR MASK
	BIC	(SP)+,(SP)		;THIS COMPLETES THE 'AND'
	BR	INTERP
;
;	OR
;
LOR:	BIS	(SP)+,(SP)		;PDP 11 HARDWARE 'OR' FUNCTION
	BR	INTERP
;
;	NEGATION
;
LNG:	COM	(SP)
	BR	INTERP
;
;		S T O R E	O P E R A T O R S
;
;	THE STORE OPERATORS STORE THE SECOND WORD IN THE STACK (VALUE)
;	IN THE WORD POINTED TO BY THE TOS (ADDRESS).
;	BOTH ARE DELETED FROM THE STACK EXCEPT IN A STON WHERE THE
;	VAULE IS LEFT ON THE STACK
;
;	STORE DESTRUCT	BOTH ADDRESS AND VALUE ARE REMOVED
;
STOD:	MOV	2(SP),@(SP)+		;STORE AND POP ADDRESS
	TST	(SP)+			;POP VALUE
	BR	INTERP
;
;	STORE NON-DESTRUCT	ADDRESS POPPED ONLY
;
STON:	MOV	2(SP),@(SP)+		;STORE AND POP ADDRESS
	BR	INTERP
;
;		P O I N T E R   S T O R E   O P E R A T O R S
;
;	ADDRESS (ON TOS) IS WHERE POINTER BELOW IT IS STORED
;	POINTER IS INDEX ON TOP OF ARRAY DESCRIPTOR
;
;	POINTER STORE DESTRUCT   -   REMOVE ALL 3 WORDS
;
PSTD:	MOV	(SP)+,R0		;GET ADDRESS OF POINTER
	MOV	2(SP),(R0)+		;STORE ARRAY PART
	MOV	(SP)+,(R0)		;STORE INDEX PART
	TST	(SP)+			;POP ARRAY PARY
	BR	INTERP			;DONE
;
;	POINTER STORE NON-DESTRUCT   -   REMOVE ONLY ADDRESS OF POINTER
;
PSTN:	MOV	(SP)+,R0		;ADDRESS OF POINTER
	MOV	2(SP),(R0)+		;STORE ARRAY PART
	MOV	(SP),(R0)		;STORE INDEX PART
	BR	INTERP
.SBTTL	FID ROUTINE
;
;		B I T	  O P E R A T O R S
;
;	THESE TWO OPERATORS DEAL WITH STORING BIT CONFIGURATIONS
;
;	FIELD ISOLATE DYNAMIC
;	THIS ONE DOES SOME CHECKING AND SETS UP THE STACK FOR THE NEXT ONE
;
;	WORD 1 IN STACK (TOS) = DESCRIPTOR (ADDRESS OF ID)
;	WORD 2 IN STACK       = VALUE OF WORD TO BE WORKED OVER
;	WORD 3 IN STACK       = # OF BITS THAT GET STORED
;	WORD 4 IN STACK       = LEFT MOST BIT #
;
FID:	MOV	6(SP),R0		;LEFT MOST BIT # INTO R0
	BMI	INVOP
	CMP	#20,R0			;TOO BIG?
	BLE	INVOP			;YES
	MOV	4(SP),R2		;# OF BITS IN R2
	BMI	INVOP			;TO SMALL!
	CMP	R2,#20			;TO BIG?
	BGT	INVOP			;YES
	SUB	R2,R0			;TO GET SHIFT COUNT
	INC	R0
	BGE	10$			;DON'T WRAP THIS ONE
	CLR	R0
10$:	MOV	(SP)+,2(SP)		;MOVE ADDRESS AROUND
	MOV	(SP),4(SP)		;MOVE VALUE AROUND
	MOV	R0,-(SP)		;SAVE SHIFT COUNT FOR FDI
	MOV	#1,R1
	ASH	R2,R1			;MOVE BIT TO PROPER PLACE
	DEC	R1			;MAKE 2** # OF BITS - 1
	MOV	R1,2(SP)		;SAVE MASK
.SBTTL	FDI ROUTINE
;
;	FIELD ISOLATE
;	WORD 1 IN STACK (TOS) = SHIFT COUNT
;	WORD 2 IN STACK       = MASK
;	WORD 3 IN STACK       = ADDRESS OF WHERE TO STORE
;	WORD 4 IN STACK       = VALUE TO BE SHIFTED
;
FDI:	MOV	6(SP),R0		;GET VALUE TO BE STORED
	MOV	(SP)+,R2		;GET SHIFT COUNT
	MOV	(SP)+,R1		;GET MASK
	COM	R1			;COMPLIMENT TO TURN OFF BITS NOT TO BE STORED
	BIC	R1,R0			;CLEAR OUT BITS NOT TO BE USED
	COM	R1			;TO GET ORIG MASK
	TST	R2			;NON-ZERO SHIFT COUNT?
	BEQ	20$			;NOPE. DONE!
10$:	CMP	#77777,R0		;PUT BIT #15 OF VALUE INTO CARRY
	ROL	R0			;THEN INTO BIT #0
	CMP	#77777,R1		;PUT BIT #15 OF MASK INTO CARRY
	ROL	R1			;THEN INTO BIT #0
	SOB	R2,10$			;LINE THEM UP
20$:	BIC	R1,@(SP)		;WHERE TO PUT NEW VALUE
					;TURN OFF BITS TO BE STORED INTO
	BIS	R0,@(SP)+		;PUT NEW VALUE THERE
	MOV	R0,(SP)			;& LEAVE ON TOS
CON.SW:	TSTB	RWT5			; IS IT ZERO
	BEQ	10$			; NOPE
	TST	(SP)+			;ONLY EXECUTED FOR CONCATS
10$:	CLRB	RWT5			; SET SWITCH INCASE IT WAS RESET
	BR	INTERP
.SBTTL >>>>>>	INSTRUCTION DECODER 
;
;
;	I N S T R U C T I O N   D E C O D E R
;
;	REGISTER ALLOCATION FOR THE INTERPRETER:
;
;	  R6 - REAL STACK POINTER
;	  R5 - IPC (INTERPRETIVE PROGRAM COUNTER)
;	  R4 - F REGISTER (STACK HISTORY POINTER)
;	  R3 - RELOCATION REGISTER (PRT BASE)
;	  R2 - R0 FREE FOR ALL
;
	.ENABL	LSB
OPDC:	JSR	PC,DECODE		;FETCH THE ADDRESS
	MOV	(R0),-(SP)		;AND THE DATA STORED THERE
	BR	INTERP			;LOOP THRU INTERPRETER
OP:	ASR	R0			;MAKE INTO A DISPATCH ADDRESS
	JMP	@DPT(R0)		;AND OFF TO THE ROUTINE

INTERP::
	.IF	DF	DEBUG
	JSR	PC,SEGCHK		;SEE IS THIS ADDRESS IS FLAGGED
	.ENDC
	MOV	(R5)+,R0		;FETCH NEXT INSTRUCTION
	MOV	R0,R1			;COPY IT AND
	BIC	#-3-1,R1		;MASK OUT THE TYPE CODE
	ASL	R1			;MAKE INTO A WORD INDEX
	ADD	R1,PC			;AND GO TO THE PROPER PLACE
	BR	LITC			;  LITERAL CALL
	BR	OP			;  OPERATOR CALL
	BR	OPDC			;  OPERAND CALL
;	BR	DESC			;  DESCRIPTOR CALL
DESC:	JSR	PC,DECODE		;FIND OUT THE ADDRESS
10$:	MOV	R0,-(SP)		; AND STACK IT
	BR	INTERP			;AND LOOP
LITC:	ROR	R0			;DIVIDE BY TWO
	ROR	R0			; AND TWO MORE
	BR	10$			;AND GO STACK IT
DECODE:	BIC	#3,R0			;GET RID OF TYPE FIELD
	ASR	R0			;AND MOVE OVER A BIT
	BMI	20$			;NOT PRT ADDRESSING
	ADD	R3,R0			;OFFSET INTO PRT
	RTS	PC			; AND EXIT
20$:	BIT	#20000,R0		;IS IT F ADDRESSING?
	BNE	30$			;YES
	BIC	#140000,R0		;CLEAR THOSE BITS
	ADD	R5,R0			;IPC RELATIVE ADDRESS
	RTS	PC			; AND EXIT
30$:	ADD	#10000,R0		;SET + OR - INTO C
	BIC	#170000,R0		;THAT MAKES F+ WORK
	BCS	40$
	NEG	R0			;NOW F- SHOULD WORK
40$:	ADD	R4,R0			;NOW STACK OFFSET
	RTS	PC			; AND EXIT

	.DSABL	LSB
.SBTTL	BRUN, BRTR, BRFL, OCX, ENTR ROUTINES.
;
;		B R A N C H	O P E R A T O R S
;
;	BRANCHING IS DONE RELATIVE TO PROGRAM BASE ADDRESS (-2)
;	CONDITIONAL BRANCHS TAKE BRANCH ON APPROPRIATE CONDITION
;	AND CLEAN THE STACK OTHERWISE
;
;

BRUN:	MOV	(SP)+,R5		;SET PC
	ADD	PBASE,R5		;MAKE RELATIVE
	BR	INTERP			;NEXT
BRTR:	MOV	(SP)+,R0		;GET ADDRESS
	ROR	(SP)+			;BRANCH IF BIT #0 = 1
	BCS	$BR			;LIKE SO
	BR	INTERP			;AND SKIPS IF FALSE (0)
BRFL:	MOV	(SP)+,R0		;GET ADDRESS
	ROR	(SP)+			;BR-FALSE TAKES BRANCH IF BIT #0 = 0
	BCS	INTERP			;AND SKIPS IF = 1
$BR:	MOV	R0,R5			;SET NEW PC
	ADD	PBASE,R5		;MAKE IT RELATIVE
	BR	INTERP			;DONE THIS WAY FOR SPEED
;
;		O C C U R E S   I N D E X
;
;	USED FOR INDEXING INTO CODE SEGMENT.
;	TOS IS INDEX INTO CASE BODY
;	2ND WORD IS MAX VALUE ALLOWED (0 IS MINIMAL VALUE ALLOWED)
;	3RD WORD IS ADDRESS OF TABLE OF SEGMENT ADDRESSES
;	IF RESPECTIVE ADDRESS IS < 0 THEN THAT INDEX IS ILLEGAL ALSO
;	OTHERWISE THAT ADDRESS IS ADDRESS WITHIN THIS SEGMENT TO GO TO
;	SO USE THE BRUN OPERATOR
;

OCX:	MOV	(SP)+,R0		;GET INDEX
	BMI	INVIDX			;< 0 => NO GOOD
	CMP	R0,(SP)+		;SEE IF TOO BIG
	BGT	INVIDX			;YES. ALSO AN ERROR
	ASL	R0			;MULTIPLY INDEX BY 2
	ADD	(SP),R0			;TO INDEX INTO CASE BODY
	MOV	(R0),(SP)		;GET ADDRESS OF STMT
	BPL	BRUN			;IT WAS GOOD
	BR	INVIDX			;INVALID CASE INDEX
;
;	ENTR	-     ENTERS ANOTHER BLOCK OF SAME PROCEDURE
;
ENTR:	MOV	(SP)+,R0		;SAVE ADDRESS OF DESCRIPTOR
	JSR	PC,GETIT		;MAKE THE SEGMENT PRESENT
	+	TYPEPR			;CODE SEGMENT TYPE MEMORY
	+	PROGFD			;FILE TO READ FROM IN CASE
	MOV	R0,PBASE		;SET NEW PROGRAM BASE REGISTER
	MOV	R0,R5			;SET NEW PROGRAM COUNTER
	TST	(R5)+			;BECAUSE R5 POINTS TO WORD BEFORE CODE
	BR	INTERP
.SBTTL	DEL, DUP, MKS, XCH, BPS, LOD ROUTINES
;
;		S T A C K	O P E R A T O R S
;
;	THESE OPERATORS MANIPULATE THE CONTENTS OF THE TOP OF THE STACK
;	OR THE STACK POINTER IT SELF
;
;	DELETE		POPS THE TOS
;
DEL:	TST	(SP)+			;POP TOS
	BR	INTERP
;
;	DUPLICATE	- PUSHES THE TOS ONTO THE STACK
;
DUP:	MOV	(SP),-(SP)		;LIKE THAT
	BR	INTERP
;
;	MARK STACK	- PUSHES PREVIOUS MSK (AT PRT+0) ONTO STACK
;			- THEN PUTS STACK POINTER IN MKS (AT PRT+0)
;
MKS:	MOV	(R3),-(SP)		;R3 POINTS TO PRT
	JSR	PC,STKCHK		;PUSH AND CHECK FOR STACK OVERFLOW
	MOV	SP,(R3)
	BR	INTERP
;
;	EXCHANGE	EXCHANGES THE TOP WORD ON STACK WITH THE WORD BELOW IT
;
XCH:	MOV	(SP)+,R0		;SAVE TOS
	MOV	(SP),-(SP)		;NEW TOS
	MOV	R0,2(SP)		;AND INSERT OLD TOS BELOW
	BR	INTERP			;THAT WASN'T HARD
;
;	BUMP STACK POINTER	TOP OF STACK CONTAINS THE # OF ZEROS TO PUSH -1
;
BPS:	MOV	(SP)+,R2		;GET # OF ZEROS - 1
	INC	R2			;NOW OK
	MOV	SP,R1			;SAVE CURRENT STACK POINTER
	ASL	R2			;DOUBLE FOR WORDS
	SUB	R2,SP			;WHERE NEW STACK POINTER WILL BE
	JSR	PC,STKCHK		;CHECK FOR STACK OVERFLOW
10$:	CLR	-(R1)			;CLEAR OUT THE STACK AREA
	SOB	R2,10$
	BR	INTERP
;
;	LOAD		REPLACES ADDRESS ON TOS BY CORRESPONDING VALUE.
;
LOD:	BIT	#1,(SP)			;TEST FOR ODD ADDRESS
	BNE	INVADD			;NO GOOD
	MOV	@(SP)+,-(SP)		;DO IT
	BR	INTERP
.SBTTL	FONE, ONES, RSDN, RSUP ROUTINES
;
;		M I S C E L L A N E O U S   O P E R A T O R S
;
;	ONES OPERATOR COUNTS THE # OF BITS ON IN A WORD
;	FIRSTONE OPERATOR RETURNS THE LEFT-MOST BIT # THAT IS ON
;		(-1 IF NONE ON)
;
;	FIRSTONE
;
FONE:	MOV	(SP),R0			;GET WORD TO FIND 1ST 1 IN
	MOV	#21,(SP)		;CAUSE WE DEC FIRST
10$:	DEC	(SP)			;NOT THIS BIT
	BEQ	INTERP			;MUST NOT HAVE FOUND A ONE!
	ROL	R0			;PUSH BIT #15 INTO CARRY
	BCC	10$			;WASN'T ON
	BR	INTERP			;ANSWER ON TOS
;
;	ONES
;
ONES:	MOV	(SP),R0			;GET WORD TO COUNT THE # OF BITS ON
	CLR	(SP)			;ANSWER
10$:	CLC				;CLEAR THE CARRY
	ROR	R0			;PULL BIT #0 INTO THE CARRY
	ADC	(SP)			;ADD BIT IF IT WAS ON
	TST	R0			;SEE IF ANY MORE ON
	BNE	10$			;YES
	BR	INTERP
;
;		R O T A T E   S T A C K   O P E R A T O R S
;
;	THESE TWO OPERATORS ROTATE THE STACK UP OR DOWN
;	INITIAL STACK CONFIGURATION IS
;		C
;		B
;		A  (TOS)
;
;	AFTER RSDN		RSUP		STACK LOOKS LIKE:
;	       B		 A
;	       A		 C
;	       C      (TOS)	 B
;
;	ROTATE STACK DOWN (IE TOS TO 4(SP))
;
RSDN:	MOV	4(SP),-(SP)		;DUP C
	MOV	2(SP),6(SP)		;MOV A TO ITS PLACE
	MOV	4(SP),2(SP)		;MOV B TO ITS PLACE
	MOV	(SP)+,2(SP)		;PUT C IN ITS PLACE
	JMP	INTERP
;
;	ROTATE STACK UP (IE 4(SP) TO TOS)
;
RSUP:	MOV	4(SP),-(SP)		;DUP C
	MOV	4(SP),6(SP)		;MOV B TO ITS PLACE
	MOV	2(SP),4(SP)		;MOV A TO ITS PLACE
	MOV	(SP)+,(SP)		;PUT C WHERE IT BELONGS
	JMP	INTERP
INVIDX:	QUIT	<?Case index out of range>
INVADD:	QUIT	<?Illegal address in load operation>
;		S T R I N G   B O U N D R Y   T E S T I N G
;
;	STEST TESTS A POINTER TO SEE IF IT POINTS OUT OF THE ARRAY IT WAS
;	ASSIGNED TO. IF SO, THIS CONSTITUTES AN ERROR CONDITION SIGNALED AS
;	'SEGMENTED ARRAY'. I.E. A POINTER WAS POINTING BEYOND THE SEGMENT
;	LIMITS.
;
;	FOR THIS ROUTINE, SOME INFORMATION IS STORED IN THE PRT. NAMELY
;	A 4 WORD BLOCK CONTAINING THE FOLLOWING INFORMATION.
;		WORD 1	- ADDRESS OF ARRAY DESCRIPTOR OF THE POINTER
;		WORD 2	- INDEX OF THE POINTER
;		WORD 3	- MEMORY DESCRIPTOR OF SEGMENT OF PREVIOUS CALL
;			  ASSOCIATED WITH THIS POINTER
;		WORD 4	- ADDRESS OF WHERE WORD 3 CAME FROM AND GOES TO.
;
;	THE 3RD AND 4TH WORDS ARE NECESSARY BECAUSE WE DON'T WANT AN ARRAY
;	ROW TO GET SWAPPED OUT ON US. SO WE MAKE IT SAVED. BUT BEFORE WE
;	DO, SAVE A COPY OF WHAT THE ORIGINAL SAVE-STATUS WAS AND WHERE
;	IT WAS SO THAT WE CAN RESTORE IT PROPERLY.
;
;	DURING EACH CALL (OTHER THAN THE 1ST). THE PREVIOUS SEGMENT DESCRIPTOR
;	IS RESTORED.
;	THE STACK, UPON ENTRANCE, LOOKS LIKE THE FOLLOWING:
;	WORD 1  (TOS)	- RETURN ADDRESS FOR RTS PC
;	WORD 2		- OFFSET INTO THE PRT OF 4-WORD BLOCK
;		THIS OFFSET IS SUCH THAT IF YOU ADD 6 PLUS THE PRT BASE
;		YOU GET THE ADDRESS OF THE 1ST ELEMENT OF THE BLOCK
;
;	UPON RETURN THE STACK LOOKS LIKE THE FOLLOWING
;	WORD 1	(TOS)	- ADDRESS OF WHERE POINTER POINTS TO.
;	WORD 2  	- LENGTH LEFT IN THIS ARRAY ROW BEFORE END OF ROW
;
;	REGISTERS REMAIN UNCHANGED
;	THIS ROUTINE AND THE SCMP,REP,SCAN OPERATORS WERE WRITTEN TO BE BOTH
;	RE-ENTRANT AND AS FAST AS POSSIBLE

STEST::	MOV	R2,-(SP)		;SAVE R2
	MOV	4(SP),R2		;GET OFFSET
	ADD	#6,R2			;PLUS 6
	ADD	R3,R2			;PLUS PRT BASE
	MOV	(SP),-(SP)		;DUP R2
	MOV	4(SP),2(SP)		;DUP RETURN ADDRESS
	MOV	R0,-(SP)		;SAVE R0
	MOV	R1,-(SP)		;AND R1 ALSO
	TST	4(R2)			;SEE IF 1ST TIME THRU
	BEQ	10$			;YES
	MOV	6(R2),@4(R2)		;RESTORE OLD MEMORY DESCRIPTOR
10$:	MOV	(R2)+,R0		;GET ADDRESS OF ARRAY DESCRIPTOR
	BEQ	INVOPP			;NO ARRAY! OH HOW HORRIBLE!!!
	MOV	(R2)+,R1		;GET INDEX
	BMI	SEGARY			;TOO SMALL !
	BIT	#40000,(R0)		;SEGMENTED ?
	BEQ	30$			;NO
	TST	4(R0)			;SEE IF DV ALLOCATED
	BGT	20$			;YES
	JSR	PC,ALLOCS		;NO. ALLOCATE IT
20$:	CLR	-(SP)			;FOR FIGURING INDEX MOD/DIV 256.
	MOVB	R1,(SP)			;INDEX MOD 256.
	CLRB	R1
	SWAB	R1			;INDEX DIV R1
	MOV	(R0)+,-(SP)		;GET ARRAY SIZE
	BIC	#160000,(SP)		;MINUS SEG-BITS & PRES BIT
	CMP	R1,(SP)+		;SEE IF TOO BIG
	BGE	SEGARY			;YES
	ASH	#3,R1			;OPTIMIZE FOR THOSE WHO CAN HACK IT
	MOV	(R0),R0			;ADDRESS OF BASE OF DV -2
	TST	(R0)+			;GET TO BASE OF DV
	ADD	R1,R0			;ADDRESS OF PROPER ENTRY
	MOV	(SP)+,R1		;NEW INDEX
30$:	TST	4(R0)			;ROW ALLOCATED YET?
	BGT	40$			;YES
	JSR	PC,ALLOC1		;ALLOCATE ROW!
40$:	MOV	(R0),-(SP)		;GET SIZE (ROW IN CORE?)
	BMI	50$			;YES
	JSR	PC,GETIT		;MAKE IT PRESENT
	+	TYPEAY			;DATA TYPE MEMORY
	+	VMEMFD			;READ FROM OVERLAY FILE
	MOV	(R0),R0			;GET ADDRESS OF DESCRIPTOR
50$:	BIC	#160000,(SP)		;GET TRUE SIZE
	BIT	#40000,4(R0)		;SEE IF FOR REAL!
	BEQ	60$			;NO. MUST BE BOOL OR INT
	ASL	(SP)			;DOUBLE ARRAY SIZE (2 WORDS/ENTRY)
60$:	ASL	(SP)			;TIMES 2 (# OF CHARS/WORD)
	SUB	R1,(SP)			;TO FIND THE # LEFT
	BLE	SEGARY			;NOT ENOUGH!
	MOV	(SP)+,12(SP)		;SAVE IN RETURN PARAMS
	MOV	2(R0),R0		;GET CA -2
	SUB	#6,R0			;GET ADDRESS OF MEMORY DESCRIPTOR
	MOV	R0,(R2)+		;STORE ADDRESS
	MOV	(R0),(R2)		;STORE WHAT WAS THERE
	BIS	#100000,(R0)		;MAKE IT SAVED
	ADD	#10,R0			;BASE OF ROW
	ADD	R1,R0			;ADDRESS OF POINTER
	MOV	R0,10(SP)		;PUT IN RETURN PARAMS
RETURN:	MOV	(SP)+,R1		;RESTORE REGS
	MOV	(SP)+,R0
	MOV	(SP)+,R2		;IN REVERSE OF ORDER SAVED
	RTS	PC			;RETURN TO CALLER
SEGARY:	QUIT	<?Segmented array>
INVOPP:	JMP	INVOP			;INVALID OPERATION
;		C O N D I T I O N A L   T E S T I N G
;
;	THIS ROUTINE USED BY SCAN AND REPLACE OPERATORS TO SEE IF CONDITION
;	IS TRUE. TOS IS RETURN ADDRESS, 2ND WORD IS ANSWER INITED TO TRUE.
;	R2 BIT #5	  0-IN,	1-ROP   (REMAINS UNTOUCHED)
;	R0 POINTS TO CHAR TO BE TESTED. R0 GETS UPDATED.
;	4(R3) IS <AEXP> FOR ROP AND ADDRESS OF TRUTHID FOR IN.
;	BOOLEAN RESULT OF 0-FALSE OR 1-TRUE IS LEFT WHERE RETURN ADDRESS IS.
;
COND:	MOV	R2,-(SP)		;SAVE R2 (BOTH ROUTINES NEED IT THAT WAY)
	BIT	#40,R2			;SEE IF ROP
	BNE	10$			;YES
	MOV	R0,-(SP)		;SAVE REGS
	INC	(SP)			;CAUSE WE'RE GOING TO INC R0
	MOV	R1,-(SP)
	CLR	-(SP)			;WHERE CHAR TO BE IN-TESTED GOES
	MOVB	(R0)+,(SP)		;CHAR TO TEST
	MOV	4(R3),-(SP)		;ADDRESS OF TRUTHID
	JSR	PC,IN
	MOV	(SP)+,10(SP)		;PUT ANSWER IN
	BR	RETURN			;UNSTORE REGS
10$:	MOV	#20$,-(SP)		; ** KLUDGE TO FIX INSTR MOD **
	MOV	#137,-(SP)		; JMP @#XXXX
	MOV	#14.,-(SP)		; 
	MOV	#5366,-(SP)		; DEC 2(SP)
	MOV	#2,-(SP)		; SKIP OVER DEC
	MOVB	13(SP),1(SP)		; SET IN HIGH PART
	CMPB	(R0)+,4(R3)		;DO THE COMPARE
	JMP	@SP			; GO DO CODE
20$:	ADD	#12.,SP			; FIX UP STACK AND FALL THROUGH
	RTS	PC			;RETURN
.SBTTL	SCMP ROUTINE
;		S T R I N G   C O M P A R E S
;
;	THIS OPERATOR ALLOWS ONE TO COMPARE TWO STRINGS OF THE FORM
;		<UPDATE><PE> <ROP> <UPDATE><PE> FOR <AE>
;		<UPDATE><PE> <ROP> <QUOTED STRING> [ FOR <AE> ]
;	TOS IS A CODE WORD IN WHICH THE FOLLOWING BITS HAVE THE FOLLOWING
;	MEANING:
;	BIT #0	- IF ON THEN QOUTED STRING COMPARISON
;	BIT #1	- IF ON THEN 2ND POINTER IS UPDATED
;	BIT #2	- IF ON THEN 1ST POINTER IS UPDATED
;	BIT 10:3- ROP (NE-2,EQ-3, ECT.)
;	WORD UNDERNEATH IS LENGTH TO DO COMPARE.
;	3RD WORD IS ADDRESS OF STRING
;		    OR
;	3RD-4TH IS 2ND POINTER
;	NEXT TWO WORDS IS 1ST POINTER
;	NEXT IS ADDRESS OF 2ND UPDATE POINTER
;	NEXT IS ADDRESS OF 1ST UPDATE POINTER
;
;	AFTER THE COMPARE STACK IS CLEARED AND THE BOOLEAN RESULT
;	OF 0 (FALSE) OR 1 (TRUE) IS LEFT ON THE STACK.
;	COMPARISON FOR 0 OR LESS RESULTS IN A TRUE IF ROP IS EQL,LEQ,GEQ
;	AND FALSE OTHERWISE.
;
SCMP:	MOV	(SP)+,R0		;SAVE CODE WORD
	MOV	(SP)+,R2		;MAX LENGTH
	BIT	#1,R0			;QUOTED STRING ?
	BNE	10$			;YES
	MOV	(SP)+,20(R3)		;SET UP 2ND POINTER
	MOV	(SP)+,16(R3)		;IN THE PRT
	CLR	22(R3)			;INDICATE 1ST TIME THRU
	BR	20$
10$:	MOV	(SP)+,R1		;GET ADDRESS OF STRING
20$:	MOV	(SP)+,10(R3)		;SET UP 1ST POINTER
	MOV	(SP)+,6(R3)		;IN THE PRT
	CLR	12(R3)			;INITIALIZE IT ALSO
	MOV	R0,-(SP)		;SAVE CODE WORD
	CLR	-(SP)			;LENGTH LEFT OF POINTERS = 0
	CLR	-(SP)			;OF 2ND ALSO
	BIT	#1,R0			;SEE IF QUOTED STRING 
	BEQ	30$			;NO
	MOV	R2,(SP)			;YES. RESET LENGTH
	INC	(SP)			;CAUSE WE CHECK BEFORE, NOT AFTER
30$:	TST	R2			;SEE IF DONE YET
	BLE	SEQL			;YEP. THAT WAS QUICK
S.AGA:	DEC	2(SP)			;1ST POINTER NEED RE-FILLING ?
	BGT	10$			;YES, IF IT WAS ZERO
	CLR	-(SP)			;YES. SET OFFSET
	JSR	PC,STEST
	MOV	(SP)+,R0		;GET NEW ADDRESS
	MOV	(SP)+,2(SP)		;GET NEW LENGTH FIELD
10$:	DEC	(SP)			;SEE IF 2ND POINTER NEEDS RE-FILLING
	BGT	20$			;NOT IF THERE WAS AT LEAST 1 CHAR
	MOV	#10,(SP)		;INDICATE 2ND POINTER THIS TIME
	JSR	PC,STEST
	MOV	(SP)+,R1		;GET ADDRESS OF 2ND POINTER
20$:	INC	10(R3)			;INC 1ST POINTER INDEX
	INC	20(R3)			;INC 2ND POINTER INDEX
	CMPB	(R0)+,(R1)+		;SEE IF EQUAL
	BNE	SNEQ			;NOPE
	SOB	R2,S.AGA		;CONTINUE TO SCAN WHILE THEY ARE
SEQL:	CMP	(SP)+,(SP)+		;CLEAN THE STACK
	CLR	R2			;INITIALIZE ANSWER TO FALSE
					;INCASE INITIAL R2 < 0
	MOVB	1(SP),R0		;GET ROP VALUE
	CMP	R0,#6			;GTR OR LEQ ?
	BGE	10$			;YES, SO OK
	CMP	R0,#4			;EQL OR NEQ ?
	BLT	10$			;YES, ALSO OK
	DEC	R0			;ELSE COM BIT #0 FOR EQUALITY TEST
10$:	ROR	R0			;SET BIT #0 INTO CARRY
	ADC	R2			;BRING IN TRUE IF SO
	BR	S.DONE
SNEQ:	CMP	(SP)+,(SP)+		;CLEAN THE STACK
	MOV	#1,R2			;INITIALIZE BOOL RESULT TO TRUE
	MOV	#T2,-(SP)		; ** KLUDGE TO FIX INSTR MOD **
	MOV	#137,-(SP)		; JMP @#XXXX
	MOV	#5302,-(SP)		; DEC R2
	MOV	#1,-(SP)		; SKIP OVER DEC
	MOVB	11(SP),1(SP)		; SET IN HIGH PART
	CMPB	-(R0),-(R1)		;COMPARE THE LAST TWO CHARS
	JMP	@SP			; GO DO CODE
T2:	ADD	#8.,SP			; FIX UP STACK AND FALL THROUGH
S.DONE:	TST	12(R3)			;1ST POINTER USED?
	BEQ	NOT.1			;NO
	MOV	14(R3),@12(R3)		;RESTORE MEM-DESCRIPTOR
NOT.1:	ROR	(SP)			;STRING ?
	BCS	10$			;YES
	TST	22(R3)			;2ND POINTER USED ?
	BEQ	10$			;NO
	MOV	24(R3),@22(R3)
10$:	ROR	(SP)			;SECOND POINTER UPDATED ?
	BCC	20$			;NO
	MOV	2(SP),R0		;GET ADDRESS OF WHERE
	MOV	16(R3),(R0)+		;STORE ARRAY ADDRESS
	MOV	20(R3),(R0)		;STORE INDEX
	MOV	(SP)+,(SP)		;PUSH CODE (WHATS LEFT OF IT)
20$:	ROR	(SP)+			;1ST POINTER UPDATED ?
	BCC	30$			;NOPE
	MOV	(SP)+,R0		;ADDRESS OF 1ST POINTER 
	MOV	6(R3),(R0)+		;STORE ARRAY NAME
	MOV	10(R3),(R0)		;STORE INDEX
30$:	MOV	R2,-(SP)		;STORE BOOLEAN RESULT
	JMP	INTERP
.SBTTL	SCAN ROUTINE
;
;		S C A N   O P E R A T O R
;
;	THIS OPERATOR IS USED FOR SCANNING PART OF AN ARRAY ROW EITHER
;	FOR A CONDITION OR FOR A LENGTH. CONDITIONS ARE OF THE FORM:
;		UNTIL  <ROP>  <AE>
;		WHILE  <ROP>  <AE>
;		UNTIL   IN    <TRUTHID>
;		WHILE   IN    <TRUTHID>
;	LENGTH IS OF THE FORM:
;		FOR <AE> [CONDITION]
;	TOP OF STACK IS A CODE WORD IN WHICH THE FOLLOWING BITS HAVE
;	THE FOLLOWING MEANING:
;	BIT #0	- IF 0 THEN UNCONDITIONAL SCAN (NO CONDITION PART)
;	BIT #1	- IF 1 THEN THERE IS A MAXCOUNT & IT IS WORD 3 IN THE STACK
;		  OTHERWISE THE MAX COUNT IS ASSUMED TO BE 77777
;	BIT #2	- IF 1 THEN RES-COUNT UPDATED. ADDRESS IS IN STACK
;	BIT #3	- IF 1 THEN POINTER UPDATED. ADDRESS IS IN THE STACK
;	BIT #4	- IF 1 THEN WHILE COND OTHERWISE UNTIL COND
;	BIT #5	- IF 1 THEN ROP OTHERWISE IN
;	BIT#10:3- ROP VALUE + 2 (NE-2,EQ-3,...)
;	WORD 2 ARITH EXP OR ADDRESS OF TRUTHID IF CONDITIONAL
;	NEXT	- MAX-LENGTH (IF BIT #1 IS ON)
;	NEXT 2	- POINTER EXPRESSION
;	NEXT	- RES-UPDATE ADDRESS IF BIT #2 IS ON
;	NEXT	- POINTER-UPDATE ADDRESS IF BIT #3 IS ON
;
SCAN:	MOV	(SP)+,R2		;GET CODE WORD INTO R2
	BIT	#1,R2			;SEE IF COND OR ADDRESS OF ID ON TOS
	BEQ	10$			;NO
	MOV	(SP)+,4(R3)		;YES. STORE IN PRT.
10$:	MOV	#77777,R1		;DEFAULT SCAN LENGTH.
	BIT	#2,R2			;SEE IF MAX LENGTH ON TOS
	BEQ	20$			;NO
	MOV	(SP)+,R1		;YES. GET IT
20$:	MOV	(SP)+,10(R3)		;GET POINTER INDEX
	MOV	(SP),6(R3)		;GET ARRAY NAME
	CLR	12(R3)			;INDICATE 1ST TIME THRU
	MOV	R1,(SP)			;PUT LENGTH ON TOS
	BLE	S.CNT			;FINISH WITH COUNT
S.RFL:	CLR	-(SP)			;TIME TO REFILL POINTER
	JSR	PC,STEST
	MOV	(SP)+,R0		;ADDRESS
	MOV	(SP)+,R1		;LENGTH
10$:	BIT	#1,R2			;SEE IF CONDITIONAL
	BEQ	NON			;NOPE
20$:	MOV	#1,-(SP)		;INIT THE COND TO TRUE
	JSR	PC,COND			;SEE IF COND IS TRUE OR FALSE
	BIT	#20,R2			;UNTIL OR WHILE?
	BEQ	40$			;UNTIL
	ROR	(SP)+			;WHILE. COND TRUE?
	BCC	S.CND			;FAIL ON CONDITION TEST
30$:	INC	10(R3)			;UPDATE POINTER
	DEC	(SP)			;1 LESS CHAR TO SCAN
	BEQ	S.CNT			;FAIL ON COUNT OUT
	SOB	R1,20$			;ANYTHING LEFT IN THE POINTER?
	BR	S.RFL			;NO. REFILL IT
40$:	ROR	(SP)+			;UNTIL. TRUE YET?
	BCC	30$			;NO. CONTINUE
S.CND:	CLR	42(R3)			;RE-SET TOGGLE
SCDONE:	ASR	R2			;FINISHED WITH
	ASR	R2			;BOTTOM 2 BITS
	ROR	R2			;RES-COUNT UPDATED?
	BCC	10$			;NO
	MOV	(SP)+,@(SP)		;STORE IT!
10$:	TST	(SP)+			;CLEAN STACK
	ROR	R2			;POINTER UPDATED?
	BCC	20$			;NO
	MOV	(SP)+,R0		;ADDRESS OF POINTER
	MOV	6(R3),(R0)+		;NAME
	MOV	10(R3),(R0)		;INDEX
20$:	TST	12(R3)			;POINTER USED?
	BEQ	30$			;NO
	MOV	14(R3),@12(R3)		;RE-STORE MEM-DESCRIPTOR
30$:	JMP	INTERP			;DONE SCAN
NON:	MOV	(SP),R0			;LENGTH LEFT TO SCAN
	CMP	R0,R1			;GET SMALLER OF THAT & POINTER LENGTH
	BLT	10$
	MOV	R1,R0			;POINTER SMALLER
10$:	SUB	R0,(SP)			;SUB THE SMALLER FROM AMT LEFT TO SCAN
	BNE	S.RFL			;STILL MORE TO SCAN. REFILL POINTER
S.CNT:	MOV	#1,42(R3)		;SET TOGGLE TO TRUE
	BR	SCDONE			;FINISHED!
.SBTTL	REP ROUTINE
;
;		R E P L A C E   O P E R A T O R
;
;	THERE ARE TWO TYPES OF REPLACES. TYPE A (STRING TO STRING) AND
;	TYPE B (ARITHMETIC CONVERT TO STRING).  THE STACK IS BUILT UP
;	BY THE COMPILER WITH A CODE WORD ON TOS IN WHICH THE BITS HAVE
;	THE FOLLOWING MEANING:
;
;	IF ON:
;	BIT #0	- CONDITION (<TRUTHID> OR  <AE>) ON TOS
;	BIT #1	- MAX TRANSFER LENGTH ON TOS. (77777 IS DEFAULT)
;	BIT #2	- SRC POINTER ON TOS (OR ADDRESS OF STRING AND LENGTH)
;	BIT #3	- TRANSFER MODE IS WORDS (ELSE BYTES)
;	BIT #4	- CONVERSION TYPE OF TRANSFER (ELSE STRING REPLACE)
;
;	FOR A STRING REPLACE THE OTHER BITS HAVE THE FOLLOWING MEANING
;	BIT #5	- IF ON THEN CONDITIONAL TRANSFER ELSE UNCONDITIONAL
;	BIT #6	- IF ON THEN WANT RESIDUAL COUNT UPDATED
;	BIT #7	- IF ON THEN WANT SOURCE POINTER UPDATED
;	BIT #8	- IF ON THEN WANT DESTINATION POINTER UPDATED
;	BIT #9	- IF CONDITIONAL TRANSFER THEN IF ON THEN WHILE ELSE UNTIL
;	BIT #10	- ""	""	    ""	   ""  IF ON THEN RELATIONAL ELSE IN
;	BIT #11	- IF ON THEN LAST TIME THRU
;	BIT #12	- IF ON THEN SOURCE IS QUOTED STRING ELSE SOURCE IS POINTER
;	BITS#15:3-RELATIONAL VALUE IF BIT 11 ON (SEE SCAN)
;
;	AND THE STACK LOOKS AS FOLLOWS
;	TOS	- CODE WORD
;	2ND	- ADDRESS OF ID, VALUE OF <AE> (IF BIT #0 ON)
;	NEXT	- MAX TRANSFER LENGTH (IF BIT #1 ON)
;	NEXT 2	- SRC POINTER (IF BIT #2 ON)
;	NEXT 2	- DESTINATION POINTER (ALWAYS)
;	NEXT	- ADDRESS OF RESIDUAL COUNT UPDATE (IF BIT 6 ON)
;	NEXT	- ADDRESS OF SRC  POINTER UPDATE (IF BIT 7 ON)
;	NEXT	- ADDRESS OF DEST POINTER UPDATE (IF BIT 8 ON)
;
;	FROM CALL TO CALL THE DEST POINTER IS REPLACED INTO THE STACK
;	FOR REASONS OF RE-ENTRANCY (PROC CALLS ECT.)
;
;	STRINGS WILL BE WRAPPED WHEN THEY RUN OUT DURING A REPLACE
;	IE. [REPLACE P BY " " FOR 40] WILL WORK.
;
;	TOGGLE IS SET IF REPLACE TERMINATES DUE TO MAXCOUNT DEPLETION
;	       AND IS RE-SET (FALSE) IF THE OPERATION IS TERMINATED DUE
;	       TO CONDITION FAILURE.
;
REP:	MOV	(SP)+,R2		;GET CODE
	ROR	R2			;COND ON TOS ?
	BCC	10$			;NO
	MOV	(SP)+,4(R3)		;PUT IN THE PRT WHERE COND EXPECTS IT
10$:	MOV	#77777,R1		;DEFAULT TRANSFER LENGTH
	ROR	R2			;MAX LENGTH ON TOS ?
	BCC	20$			;NO. USE DEFAULT
	MOV	(SP)+,R1		;GET USERS!
20$:	ROR	R2			;SOURCE POINTER OR STRING ON TOS ?
	BCC	30$			;NO
	MOV	(SP),24(R3)		;IN CASE OF STRING
	MOV	(SP)+,20(R3)		;INDEX
	MOV	(SP)+,16(R3)		;ARRAY NAME
30$:	CLR	22(R3)			;CLEAR USED WORD
	CLR	12(R3)			;CLEAR USER WORD IN 1ST POINTER
	MOV	(SP)+,10(R3)		;DEST INDEX
	MOV	(SP)+,6(R3)		;DEST NAME
	ROR	R2			;WORDS(1) OR BYTES(0)
	BCC	40$			;BYTES. OK!
	ASL	R1			;MUL TRANS LENGTH BY 2
	INC	10(R3)			;ROUND DEST POINTER TO NEAREST WORD
	BIC	#1,10(R3)		;LIKE SO
	INC	20(R3)			;SAME WITH SRC POINTER
	BIC	#1,20(R3)
40$:	BIC	#174000,R2		;MAKE RELATIONAL VALUE GOOD
	CLC				;WHAT WE WILL BRING IN
	ROR	R2			;CONVERSION?
	BCS	ARITH			;YES
	MOV	R1,-(SP)		;MAX LENGTH
	CLR	-(SP)			;LENGTH LEFT OF DEST PTR
	CLR	-(SP)			;LENGTH LEFT OF SRC PTR
	TST	R1			;ANY TRANSFER?
	BLE	R.CNT			;NOPE!
	MOV	16(R3),R0		;IN CASE OF STRING !
	ADD	24(R3),R0		;BACK UP STRING POINTER!
R.AGA:	DEC	2(SP)			;1 LESS CHAR FOR DEST PTR
	BGT	20$			;OK
	CLR	-(SP)			;NEEDS A RE-FILL
	JSR	PC,STEST		;FILL IT
	MOV	(SP)+,R1		;ADDRESS
	MOV	(SP)+,2(SP)		;LENGTH
	CMP	12(R3),22(R3)		;THIS IS ADDED TO PREVENT MEMORY FROM
	BNE	10$			;FROM GETTING LOCKED INTO CORE 'CAUSE
	MOV	24(R3),14(R3)		;2ND POINTER GETS FREED 1ST
10$:	BIS	#4,14(R3)		;TURN ON WRITTEN INTO BIT!
20$:	DEC	(SP)			;1 LESS CHAR FROM SRC PTR
	BGT	40$			;IS OK
	TSTB	R2			;STRING AS A SOURCE?
	BMI	30$			;YES
	MOV	#10,(SP)		;NO. FILL SRC PRT (#2)
	JSR	PC,STEST
	MOV	(SP)+,R0		;GET ADDRESS LEAVE LENGTH
	BR	40$
30$:	SUB	24(R3),R0		;BACK UP STRING
	MOV	24(R3),(SP)		;RESET LENGTH
40$:	BIT	#1,R2			;COND(1) OR UNCOND(0)
	BEQ	TRUN			;TRANSFER UNCONDITIONAL
	MOV	#1,-(SP)		;CONDITIONAL. SET TO TRUE
	JSR	PC,COND			;CHECK IT OUT
	DEC	R0			;BACK UP TO CHAR JUST LOOKED AT
	BIT	#20,R2			;WHILE(1) OR UNTIL(0)?
	BEQ	UNTIL			;UNTIL!
	ROR	(SP)+			;CONDITION TRUE?
	BCC	R.COND			;NO. FAIL DUE TO CONDITION
TRUN:	MOVB	(R0)+,(R1)+		;MOVE CHARACTER
	INC	10(R3)			;UPDATE INDEX OF DEST
	INC	20(R3)			;UPDATE INDEX OF SRC
	DEC	4(SP)			;MORE LEFT?
	BNE	R.AGA			;YES!
R.CNT:	MOV	#1,42(R3)		;SET TOGGLE TO TRUE
R.DONE:	CMP	(SP)+,(SP)+		;POP LENGTHS
	MOV	(SP)+,R1		;CLEAN LENGTH INTO R1
	ASR	R2			;DONE WITH CONDITIONAL BIT
	ROR	R2			;RESIDUAL COUNT UPDATED
	BCC	10$			;NO
	MOV	R1,@(SP)+		;UPDATE IT!
10$:	ROR	R2			;SRC UPDATED?
	BCC	20$			;NO
	MOV	(SP)+,R0		;GET ADDRESS OF POINTER
	MOV	16(R3),(R0)+		;SAVE ARRAY NAME
	MOV	20(R3),(R0)		;SAVE INDEX
20$:	ROR	R2			;DEST UPDATED?
	BCC	30$			;NO
	MOV	(SP)+,R0		;GET ADDRESS OF UPDATED POINTER
	MOV	6(R3),(R0)+		;SAVE NAME
	MOV	10(R3),(R0)		;AND INDEX
30$:	TST	22(R3)			;SRC POINTER USED?
	BEQ	40$			;NO
	MOV	24(R3),@22(R3)		;RE-STORE MEM-DESCRIPTOR
40$:	TST	12(R3)			;DEST POINTER USED?
	BEQ	50$			;NO
	MOV	14(R3),@12(R3)		;RE-STORE MEM-DESCRIPTOR
50$:	BIT	#4,R2			;LAST TIME THRU?
	BNE	60$			;YES. DONE.
	MOV	6(R3),-(SP)		;OTHERWISE SAVE DEST PTR IN THE STACK
	MOV	10(R3),-(SP)
60$:	JMP	INTERP			;GET NEXT INSTR
UNTIL:	ROR	(SP)+			;NOW CHECK CONDITION
	BCC	TRUN			;DO THIS UNTIL CONDITION IS TRUE
R.COND:	CLR	42(R3)			;CLEAR TOGGLE FOR FAILING ON CONDITION
	BR	R.DONE
;	CONVERSION-TYPED TRANSFERS.
;	IN CODEWORD THE HIGH ORDER BITS HAVE THE FOLLOWING MEANING.
;	BIT #5	- NOT USED
;	BIT #6	- IF ON THEN UPDATE THE RESIDUAL COUNT
;	BIT #7	- IF ON THEN UPDATE THE SRC POINTER
;	BIT #8	- IF ON THEN UPDATE THE DEST POINTER
;	BIT #10:2-NOT USED
;	BIT #11	- IF ON THEN THIS IS THE LAST TIME THRU
;	BIT #12 - IF ON THEN ZERO-SUPPRESS LEADING ZEROS
;	BIT #14:2-INDICATES WHICH BASE THE CONVERSION IS TO BE INTO.
;		  0-BINARY,1-OCTAL,2-HEX,3-DECIMAL
;	BIT #15	- NOT USED
;
;	STACK IS SET UP AS IN REGULAR REPLACE.
;
ARITH:	CLR	-(SP)			;FUDGE STACK TO LOOK JUST
	CLR	-(SP)			;LIKE AFTER A REGULAR REPLACE
	MOV	R1,-(SP)		;LENGTH OF TRANSFER! (ANY)
	BLE	A.RET			;NOTHING TO DO ABOUT NOTHING!
	MOV	R2,-(SP)		;SAVE CODE WORD
	MOV	R1,R0			;SAVE LENGTH FOR CONVERT ROUTINE
	MOV	4(R3),R1		;# TO BE CONVERTED
	MOV	#60,4(R3)		;BASE FOR CHARACTERS
	MOV	#60,24(R3)		;BASE FOR ZERO-SUPPRESSED CHARS
	TSTB	R2			;ZERO SUPPRESS OPTION?
	BGE	10$			;NO
	MOV	#40,24(R3)		;FOR A SPACE!
10$:	CLRB	R2			;TIME TO GET BASE OF CONVERSION
	SWAB	R2			;GET INDEX INTO BASES ARRAY!
	MOVB	BASES(R2),R2		;GET BASE!
	CLR	-(SP)			;FILL DEST POINTER
	JSR	PC,STEST
	BIS	#4,14(R3)		;WRITTEN INTO BIT!
	MOV	(SP)+,16(R3)		;SAVE ADDRESS (FUDGE HERE SO THAT
	MOV	(SP)+,20(R3)		;SAVE LENGTH  (ERROR ROUTINE CAN USE ALSO
	JSR	PC,CONVRT		;DO IT!
	MOV	(SP)+,R2		;GET OLD CODE WORD
	CLR	(SP)			;LENGTH. WE DID IT ALL.
A.RET:	MOV	(SP),4(SP)		;PUT LENGTH WHERE R.DONE WILL EXPECT IT
	BR	R.CNT			;FINISH DUE TO COUNT OUT
CONVRT:	MOV	R0,-(SP)		;SAVE LENGTH
	CLR	R0			;GET READY FOR DOUBLE PRECISION DIVIDE
	DIV	R2,R0			;DIVIDE BY BASE
	ADD	4(R3),R1		;MAKE INTO A FUNNY PERSON (IE. A CHARACTER)
	CMP	R1,#'9			;IF REMAINDER > 9
	BLE	10$
	ADD	#7,R1			;THEN ADD OFFSET TO MAKE A THRU F
10$:	MOV	R1,-(SP)		;SAVE REMAINDER
	MOV	R0,R1			;NEXT DIVIDEND
	BGT	20$			;NOT ZERO!
	MOV	24(R3),4(R3)		;GET ZERO-SUPPRESS OPTION CHAR!
20$:	MOV	2(SP),R0		;GET PREV LENGTH
	MOV	(SP)+,(SP)		;PUSH THE REMAINDER
	DEC	R0			;1 LESS TIME TO GO
	BEQ	C.FIN			;DONE!
	JSR	PC,CONVRT		;NOT DONE YET. GET CHAR BEFORE THIS ONE
C.CONT:	MOVB	(SP)+,(R0)+		;MOVE THE REMAINDER OUT
	INC	10(R3)			;UPDATE POINTER
	DEC	R1			;1 LESS CHAR IN THIS POINTER
	BNE	10$			;STILL SOME LEFT!
	CMP	(SP),#C.CONT		;FUDGE TO PREVENT UNNECESSARY
	BNE	10$			;FILLING (FOR REPLACEING EXACTLY TO END)
	CLR	-(SP)			;FILL THE POINTER
	JSR	PC,STEST
	BIS	#4,14(R3)		;WRITTEN INTO BIT
	MOV	(SP)+,R0		;ADDRESS INTO R0
	MOV	(SP)+,R1		;AND LENGTH INTO R1
10$:	RTS	PC			;RETURN TO CALLER
C.FIN:	MOV	16(R3),R0		;GET ADDRESS INTO R0
	MOV	20(R3),R1		;AND LENGTH INTO R1
	BR	C.CONT			;AND START THE ACTUAL REPLACE OPERATION
BASES:	.BYTE	2,8.,16.,10.		;FOR 0,1,2,3 RESPECTFULLY
.SBTTL	PLOAD ROUTINE
;
;		P O I N T E R   L O A D
;
;	THIS OPERATOR LOADS THE BIT IMAGE THAT A POINTER POINTS TO FOR THE
;	SPECIFIED # OF BITS. IF THE VALUE BECOMES > 177777R8 THEN A STRING
;	TOO LONG ERROR MESSAGE IS GENERATED.
;	1ST WORD  (TOS)	- # OF BYTES TO LOAD
;	2ND-3RD WORDS	- POINTER TO LOAD FROM
;
;	A ZERO OR NEGATIVE LENGTH RESULTS IN A ZERO BEING LOADED

PLOAD:	MOV	(SP)+,R2		;GET LENGTH
	MOV	(SP)+,10(R3)		;SET UP THE TEMP POINTER IN THE PRT
	MOV	(SP),6(R3)
	CLR	(SP)			;INITIALIZE THE ANSWER
	CLR	12(R3)			;INITIALIZE IT
	TST	R2			;SEE IF ANY THING TO LOAD
	BLE	P.EXIT			;DONE ALREADY!
10$:	CLR	-(SP)			;TIME TO RE-FILL THE 1ST POINTER
	JSR	PC,STEST
	MOV	(SP)+,R0		;ADDRESS
	MOV	(SP)+,R1		;LENGTH
20$:	TSTB	1(SP)			;TEST FOR OVERFLOW
	BNE	P.ERR			;WOOPS. TOO BIG
	SWAB	(SP)			;MUL BY 256
	MOVB	(R0)+,(SP)		;STORE NEW CHAR
	INC	10(R3)			;UPDATE POINTER
	DEC	R2			;# OF CHARS LEFT TO LOAD
	BEQ	30$			;DONE
	DEC	R1			;# OF CHARS LEFT OS 1ST POINTER
	BNE	20$			;STILL SOMETHING LEFT
	BR	10$			;TIME TO RE-FILL IT
30$:	MOV	14(R3),@12(R3)		;RE-STORE MEM-LINKS
P.EXIT:	JMP	INTERP
P.ERR:	QUIT	<?String too long>
.SBTTL	REL, SAV ROUTINES
;
;		S T O R A G E	  O P E R A T O R S
;
;	THESE OPERATORS DEAL WITH THE STORAGE OF DATA, IN PARTICULAR THE
;	STORAGE OF STRINGS.
;	SAV MAKES A STRING (OR PROCEDURE) PRESENT AND MARKS IT SAVE SO THAT
;	    IT WON'T GET SWAPPED OUT WHILE BEING READ FROM OR WRITTEN INTO.
;	REL RELEASES STORAGE BY TURNING OFF THE SAVE BIT.  SEGMENTED ARRAYS
;	    AND 2 DIMENSION ARRAYS ARE COMPLETELY FREED TO THE POINT OF
;	    TURNING OFF PRESENT BIT.  THIS ALLOWS THE AREA TO BE OVERLAID
;	    IF NEED BE.
;
;
REL:	MOV	(SP)+,R0		;GET DESCRIPTOR ADDRESS IN R0
	MOV	#INTERP,-(SP)		;FAKE A JSR TO R.DOPE FOR LATER
	CLR	R2			;INDICATE MAKEING UNSAVE, NOT FREEING MEMORY
$$REL:	MOV	2(R0),R1		;GET CA OF ARRAY ROW
	BIT	#60000,(R0)		;SEE IF SEGMENTED OR TWO DIM
	BNE	R.DOPE			;YES! OH WELL, YA CAN'T WIN EM ALL
R.CONT:	MOV	#1,-(SP)		;SO WE FALL THRU 1ST TIME
	MOV	R0,-(SP)		;ADDRESS OF ARRAY DESCRIPTOR ONTO TOS
	TST	4(R0)			;SEE IF ALLOCATED YET
	BLE	R.ENDL			;NOT ALLOCATED YET
	BR	R.DATA			;AND KLUDGE THE RE-USEABLE CODE
R.DOPE:	TST	4(R0)			;SEE IF DV ALLOCATED YET
	BLE	R.CONT			;IF NOT THEN EXIT AS IF A SINGLETON
	MOV	(R0),-(SP)		;GET # OF ROWS TO TOS
	BIC	#160000,(SP)		;TURN OFF PRESENTS AND INDICATOR BITS
	TST	(R1)+			;GET TO START OF 1ST ROW
	ADD	R2,PC			;FIND OUT IF FREEING MEMORY OR RELEASING IT
	BR	REL.1$			;RELEASING IT
	CLR	-10(R1)			;CLEAR THIS SEGMENTS IN-USE AND SAVE BITS
	MOV	R1,R0			;GET READY TO FORGET THIS AREA ALSO
	SUB	#10,R0
	JSR	PC,FORGET		;LET FORGET LOOK AT THE MEMORY!
REL.1$:	MOV	R1,-(SP)		;SAVE ADDRESS OF NEXT ROW TO BE TESTED
R.LOOP:	MOV	(SP),R0			;GET DESCRIPTOR
	TST	4(R0)			;SEE IF ROW WAS ALLOCATED
	BLE	R.ENDL			;NO. NOTHING TO DE-ALLOCATE!
	MOV	2(R0),R1		;GET CA
	BIT	#60000,(R0)		;SEE IF SEGMENTED OR TWO DIM
	BEQ	R.DATA			;NO - MUST BE 1 DIM
	JSR	PC,R.DOPE		;RELEASE THIS VECTOR
	BR	R.ENDL			;AND GET TO NEXT VECTOR
R.DATA:	ADD	R2,PC			;SEE IF FREEING (2) OR RELEASING (0)
	BR	REL.2$			;RELEASING
	TST	(R0)			;SEE IF ROW IS PRESENT
	BPL	10$			;IF NOT THEN DON'T DE-ALLOCATE !
	SUB	#6,R1			;POINT TO 1ST MEM-LINK
	CLR	(R1)			;MAKE AREA NON-PRESENT SO FORGET WON'T SCREW
	MOV	R0,-(SP)		;SAVE R0 FOR NOW
	MOV	R1,R0			;SAVE A POINTER
	JSR	PC,FORGET		;FREE MEMORY INTO LIST
	MOV	(SP)+,R0		;GET R0 BACK AGAIN
10$:	MOV	(R0),R1			;GET SIZE OF AREA
	BIC	#160000,R1		;LEAVE JUST THE SIZE, PLEASE
	MOV	A$DISK(R0),R0		;AND DISK ADDRESS
	JSR	PC,RETDSK		;AND GIVE IT BACK
R.ENDL:	ADD	R2,PC			;IF DE-ALLOCATING
	BR	R.FIN			;THEN RESET POINTERS THAT POINT TO US
	MOV	PTRLNK,R0		;START WITH LAST POINTER DECLARED
10$:	CMP	-4(R0),(SP)		;SEE IF ARRAY JUST DE-ALLOCATED
	BNE	20$			;IS POINTED TO BY ANOTHER POINTER
	CLR	-4(R0)			;IF SO THEN RE-INITIALIZE IT
20$:	MOV	(R0),R0			;GET NEXT POINTER
	BNE	10$			;LAST IS GROUNDED WITH A ZERO
R.FIN:	ADD	#10,(SP)		;4 WORDS/VECTOR IS 10 BYTES
	DEC	2(SP)			;DEC # OF ROWS LEFT
	BNE	R.LOOP			;LOOP UNTIL DONE. I.E. NO ROWS LEFT
	CMP	(SP)+,(SP)+		;CLEAR THE STACK
	RTS	PC			;RETURN TO CALLER
REL.2$:	TST	(R0)			;SEE IF PRESENT
	BPL	R.FIN			;IF NOT THEN JUST RETURN
	BIC	#100000,-6(R1)		;REL OP JUST TURNS OFF THE SAVE BIT
	BR	R.FIN			;AS WE WERE


;		S A V E   F U N C T I O N
;	SAVES ARRAYS (IF TOS = 0) OR PROCEDURE SEGMENTS
;	TOS IS ADDRESS OF DESCRIPTOR (OR 0 FOR ARRAYS)
;	2ND WORD (FOR ARRAYS ONLY) IS ADDRESS OF ARRAY DESCRIPTOR
SAV:	MOV	(SP)+,R0		;ASSUME PROGRAM SEG
	BNE	10$			;WOOPS! WAS REALLY AN ARRAY
	MOV	(SP)+,R0		;GET ADDRESS OF ARRAY DESCRIPTOR
	BIT	#60000,(R0)		;SEGMENTED OR 2-DIM?
	BNE	30$			;YES. CAN'T SEE DOING THIS.
	MOV	R0,-(SP)		;ARRAY DESCRIPTOR FOR GETARY
	JSR	PC,GETARY
	BR	20$
10$:	JSR	PC,GETIT		;MAKE IT PRESENT
	+	TYPEPR			;CODE TYPE MEMORY SEGMENT
	+	PROGFD			;READ FROM CODE FILE
20$:	BIS	#M.SAVE,M$TYPE-M$PNTR(R0) ;MAKE IT SAVE
30$:	JMP	INTERP
.SBTTL	SBR ROUTINE
;
;		S U B R O U T I N E   O P E R A T O R S
;
;	THESE TWO OPERATORS ALLOW FOR ENTRANCE TO AND EXIT FROM
;	SUBROUTINES (PROCEDURES FOR YOU ALGOL NUTS).
;
;	SUBROUTINE ENTRANCE ENTAILS:
;	  1. CALLING THE CODE SEGMENT INTO CORE (IF NOT PRESENT)
;	  2. STORING THE CURRENT PROGRAM COUNTER (RELATIVE) ON THE STACK
;	  3. STORING THE POINTER TO THE CURRENT PROGRAM SEGMENT
;	  4. PUSHING THE F-REGISTER ONTO THE STACK
;	  5. PUTTING THE CURRENT STACK POINTER INTO THE F-REGISTER
;	  6. STORING A POINTER TO THE LAST ALLOCATED ARRAYS,
;		POINTERS, AND FILES.
;
SBR::	MOV	(SP)+,R0		;STORE SEGMENT DESCRIPTOR
	JSR	PC,GETIT		;MAKE IN PRESENT
	+	TYPEPR			;CODE TYPE MEMORY SEGMENT
	+	PROGFD			;READ FROM THE CODE FILE
	MOV	R5,-(SP)		;SAVE RELATIVE PROGRAM COUNTER
	SUB	PBASE,(SP)		;RELATIVE TO CURRENT SEGMENT BASE
	MOV	@PBASE,-(SP)		;GET POINTER TO PROGRAM DESCRIPTOR
	MOV	R0,PBASE		;SAVE NEW PROGRAM BASE (RETURNED BY GETIT)
	MOV	R0,R5			;SET UP NEW PROGRAM COUNTER
	TST	(R5)+			;ADD 2 BECAUSE R0 POINTS TO WORD BEFORE CODE
	MOV	R4,-(SP)		;NOW CONSTRUCT
	MOV	SP,R4			;THE RCW (RETURN CONTROL WORD)
	MOV	ARYLNK,-(SP)		;PUSH LAST POINTER OF LAST BLOCK
	JSR	PC,STKCHK		;& CHECK FOR STACK OVERFLOW
	MOV	FILINK,-(SP)		;PUSH FILE LINKAGE
	MOV	PTRLNK,-(SP)		;AND POINTER LINKAGE
	JMP	INTERP
.SBTTL	RTN ROUTINE
;
;	SUBROUTINE EXIT IS ACCOMPLISHED THUSLY:
;	  1. DEALLOCATE ANY LOCAL ARRAYS
;	  2. CLOSE ANY LOCALLY OPENED FILES
;	  3. DE-LINK ANY LOCAL POINTERS
;	  4. RELOAD THE F-REGISTER FROM THE STACK
;	  5. MAKE SURE CALLING SEGMENT IS IN CORE
;	  6. RESET PROGRAM COUNTER AND PROGRAM BASE
;
RTN:	MOV	-2(R4),R0		;GET POINTER TO TEMPORARY ARRAY LINKS
	MOV	-6(R4),PTRLNK		;UNLINK THE POINTERS. (THAT'S EASY)
	MOV	-4(R4),R1		;NOW TO CLOSE ANY OPEN FILES
RTN.1A:	MOV	6(R1),R1		;GET TO FILES DECLARED IN THIS BLOCK
	BEQ	RTN.1B			;DONE
	MOV	2(R1),R2		;GET TO OPEN BIT
	TST	2(R2)			;WHICH IS BIT #15 HERE
	BPL	20$			;IF NOT OPEN THEN DON'T CLOSE
	MOV	R1,RWT1
	MOV	#3,RWT1+2		; ** TEMP **
	CALLX	SYSTEM			; WAS JSR R5, ????? - CLOSE IT
10$:	MOV	2(R1),R2		;GET TO POINTER TO ALGOL FIB
20$:	SUB	#6,R2			;POINT R2 TO 1ST MEM-LINK
	CLR	(R2)			;MAKE DESCRIPTOR NON-PRESENT FOR FORGET
	MOV	R0,-(SP)		;SAVE R0
	MOV	R2,R0			;GET POINTER HERE FOR CALL
	JSR	PC,FORGET		; TO FORGET IT
	MOV	12(R2),R2		;GET TO LINK BLOCK!
	SUB	#6,R2			;POINT TO 1ST MEM-LINK
	CLR	(R2)			;MAKE DESCRIPTOR NON-PRESENT
	MOV	R2,R0			;GET MEMORY POINTER HERE
	JSR	PC,FORGET		; FOR FORGETTING
	MOV	(SP)+,R0		;AND NOW RESTORE R0
	BR	RTN.1A
RTN.1B:	MOV	-4(R4),R2		;RESET FILE POINTER
	CLR	6(R2)			;GROUND IT
	MOV	R2,FILINK		;RESET THE POINTER
	MOV	(R0),R0			;GET NEXT ARRAY LINK
	BEQ	RTN.2$			;ALL DONE
	MOV	#2,R2			;SET FREE INDICATOR (R2 TO #2)
RTN.1$:	MOV	(R0)+,-(SP)		;SAVE THIS R0
	JSR	PC,$$REL		;RELEASE THIS BABY
	MOV	(SP)+,R0		;GET OLD R0
	BNE	RTN.1$			;GET NEXT LINK
RTN.2$:	CLR	@-2(R4)			;ZERO FORWARD POINTER FOR NEXT ARRAY
	MOV	-2(R4),ARYLNK		;RESET THE LOCAL ARRAY POINTER
	MOV	R4,SP			;CLEAN UP THE STACK THRU THE RCW
	MOV	(SP)+,R4		;RESET THE F REGISTER
	MOV	(SP)+,R0		;POP DESCRIPTOR OF OLD SEGMENT
	JSR	PC,GETIT		;MAKE IT PRESENT
	+	TYPEPR			;CODE TYPE MEMORY
	+	PROGFD			;FROM THE CODE FILE
	MOV	R0,PBASE		;PROGRAM BASE RETURNED IN R0 FROM GETIT
	MOV	R0,R5			;SET PROGRAM COUNTER
	ADD	(SP)+,R5		;TO NEXT INSTRUCTION TO BE EXECUTED
	MOV	(R3),SP			;RESET STACK POINTER FROM LAST MKS
	MOV	(SP)+,(R3)		;SET MKSW TO NEXT MSK
	JMP	INTERP
.SBTTL	B1D, B2D ROUTINES
;
;		A R R A Y   B U I L D E R S
;
;	B1D (B2D) BUILDS A 1 (2) DIMENSIONAL ARRAY DESCRIPTOR IN THE PRT
;	TOS IS THE REAL TOG (PLUS SEG TOG FOR B1D)
;	2ND WORD   - UPPER LIMIT OF ARRAY ROW
;	3RD WORD   - LOWER LIMIT OF ARRAY ROW
;	4TH WORD   - UPPER LIMIT OF DOPE VECTOR	( ONLY FOR B2D )
;	5TH WORD   - LOWER LIMIT OF DOPE VECTOR ( ONLY FOR B2D )
;	ON ACCOUNT OF THE INDEXING COMPUTATION DONE IN GETARY, THE
;	MAXIMUM INDEX FOR REAL SEGMENTED ARRAY ROWS IS 37777 (16383),
;	BOOL OR INT SEGMENTED ROWS IS 77777 (32767), AND LONG ARRAY
;	ROWS IS 17777 (8191).
;
;	BUILD 1 DIMENSIONAL DESCRIPTOR
;
B1D:	CLR	16(R3)			;CLEAR THE CORE ADDRESS
	CLR	20(R3)			;AND THE DISK ADDRESS
	MOVB	1(SP),15(R3)		;SET THE SEG TOG
	CLRB	14(R3)			;CLEAR REST OF DESCRIPTOR
	ROR	(SP)+			;REAL TOG
	BCC	10$			;NOT 'REAL'LY
	DEC	20(R3)			;SET DA TO < 0
10$:	MOV	(SP),-(SP)		;SEE IF WE CAN NOT-SEGMENT THIS
	SUB	4(SP),(SP)		;UPPER-LOWER
	INC	(SP)			;PLUS 1
	BGE	20$			;WITH LOWER BOUND OF ZERO
	CLR	(SP)
20$:	BIC	#160000,(SP)		;TURN OFF THOSE BITS
	CMP	(SP),#256.		;IF ROW > 256 WORDS
	BGT	40$			;THEN LEAVE SEG TOG AS IS
	TST	20(R3)			;IS THIS FOR REAL ?
	BEQ	30$			;NO. INT OR BOOL!
	CMP	(SP),#128.		;REALS <= 128 FOR AUTO NON-SEGMENTATION
	BGT	40$
30$:	CLR	14(R3)			;CLEAR SEG TOG IF IT WAS ON
40$:	TST	(SP)+			;CLEAR STACK
COMMON:	SUB	2(SP),(SP)		;GET SIZE OF ROW (OR DOPE VECTOR)
	INC	(SP)			;= UPPER - LOWER + 1
	BGE	10$
	CLR	(SP)
10$:	BIT	#40000,14(R3)		;SEGMENTED?
	BNE	20$			;YES
	BIC	#160000,(SP)		;TURN OFF THOSE BITS
	BIS	(SP)+,14(R3)		;PUT INTO THE MOM
	BR	30$
20$:	MOV	(SP)+,16(R3)		;PUT SEGMENTED SIZE IN CA
30$:	MOV	(SP)+,22(R3)		;PUT LOWER LIMIT IN 4TH WORD
	JMP	INTERP
;
;	BUILD 2 DIMENSIONAL ARRAY DESCRIPTOR
;
B2D:	CLR	20(R3)			;DISK ADDRESS
	MOV	#20000,14(R3)		;SET 2-DIMENSIONAL BIT
	ROR	(SP)+			;IS THIS FOR REAL ?
	BCC	10$			;NOPE!
	DEC	20(R3)			;SET REAL TOG
10$:	SUB	2(SP),(SP)		;GET SIZE OF ARRAY ROW
	INC	(SP)
	BGT	20$
	CLR	(SP)
20$:	BIC	#160000,(SP)		;MAKE GOOD
	MOV	(SP)+,16(R3)		;PUT IN THE CA
	MOV	(SP)+,24(R3)		;PUT AFTER THE DESCRIPTOR
	BR	COMMON			;DO ROW AS ABOVE
.SBTTL	BLD, PLNK ROUTINES
;
;	A R R A Y   B U I L D E R   A N D   P O I N T E R   L I N K E R
;
;	THE ARRAY BUILDER COPIES THE TEMPORARY ARRAY DESCRIPTOR OUT OF THE
;	PRT TO THE ADDRESS OF THE ARRAY DESCRIPTOR GIVEN IN THE STACK.
;	IF THE ARRAY IS OWN IT IS PRE-LINKED TO THE 1ST ARRAY
;	OTHERWISE IT IS POST-LINKED TO THE LAST ARRAY DECLARED
;	1ST WORD  (TOS)	- ADDRESS OF ARRAY DESCRIPTOR PLUS 6
;	2ND WORD	- OWN TOG
;
BLD:	MOV	R3,R1			;GET ADDRESS OF 22(R3)
	ADD	#22,R1			;LIKE SO
	MOV	(SP)+,R0		;WHERE TO PUT THE ARRAY
	MOV	(SP),R2			;SAVE OWN TOG
	ROR	(SP)+			;IS THIS ONE OWNED ?
	BCC	10$			;NO
	TST	-10(R0)			;TEST ARRAY LINK
	BEQ	10$			;ALLOCATED ARRAYS NOT ZERO
	JMP	INTERP
10$:	MOV	(R1),(R0)		;LOWER LIMIT
	MOV	-(R1),-(R0)		;DISK ADDRESS
	MOV	-(R1),-(R0)		;CORE ADDRESS
	MOV	-(R1),-(R0)		;DESCRIPTOR
	BIT	#20000,(R0)		;2-DIM
	BEQ	20$			;YES. GET SOME GLASSES
	JSR	PC,ALLOC2		;ALLOCATE DOPE VECTOR
20$:	ROR	R2			;OWN?
	BCC	30$			;NO
	MOV	RWT2,-(R0)		;POINT THIS ARRAY TO PREVIOUS 1ST ARRAY
	MOV	R0,RWT2			;MAKE THIS THE NEW 1ST ONE
	JMP	INTERP			; WAS FSTARY ***
30$:	CLR	-(R0)			;CLEAR THE BOTTOM POINTER
	MOV	R0,@ARYLNK		;POINT LAST ARRAY TO THIS ONE
	MOV	R0,ARYLNK		;MAKE THIS THE NEW LAST ONE
	JMP	INTERP
;		P O I N T E R   L I N K A G E
;
;	LINK POINTERS TO POINT TO LAST POINTER DECLARED.
;	OWN POINTERS ARE PRE-LINKED TO BEGINING OF LIST
;	TOS IS ADDRESS OF POINTER LINK
;	2ND WORD IS OWN TOG
;
PLNK:	MOV	(SP)+,R0		;ADDRESS OF LINK
	ROR	(SP)+			;OWN TOG
	BCC	P.1$			;NOPE
	TST	(R0)			;SEE IF LINKED YET
	BNE	P.2$			;YEP
	CMP	R0,FSTPTR		;IS THIS AT THE BOTTOM
	BEQ	P.2$			;YES DON'T RE-LINK
	MOV	R0,@FSTPTR		;PRE-LINK TO BEGINING
	CLR	(R0)			;INITIALIZE IT TO GROUND
	MOV	R0,FSTPTR		;SAVE NEW 1ST LINK
	BR	P.2$
P.1$:	MOV	PTRLNK,(R0)		;POST LINK TO END
	MOV	R0,PTRLNK		;SAVE
P.2$:	JMP	INTERP
.SBTTL	DPL, AOC, XADC, ASD, ASN ROUTINES
;
;		A R R A Y	O P E R A T O R S
;
;	THESE OPERATORS HANDLE ALL THE ARRAY OPERATIONS.
;	ARRAY OPERAND CALL EXPECTS TOS TO CONTAIN THE ADDRESS OF THE
;	      DESCRIPTOR WITH THE SUBSCRIPTS UNDERNEATH IT.
;	ARRAY DESCRIPTOR CALL, ARRAY STORE DESTRUCT, AND ARRAY STORE
;	      NON-DESTRUCT ALL EXPECT THE TOS TO BE THE ADDRESS OF
;	      THE ARRAY DESCRIPTOR FOLLOWED BY SOME VALUE FOLLOWED
;	      BY THE SUBSCRIPTS.
;
;	ARRAY DUPLICATE & LOAD. DUPS INDEXES AND LOADS VALUE
;
DPL:	BIT	#20000,@(SP)		;SEE IF 2 DIM
	BEQ	10$			;NO
	MOV	2(SP),-(SP)		;YES. BETTER GET A LIGHT.
	MOV	2(SP),-(SP)		;COPY ARRAY NAME
	MOV	10(SP),4(SP)		;COPY 2ND DIM
	BR	AOC
10$:	MOV	(SP),-(SP)		;COPY ARRAY NAME
	MOV	4(SP),2(SP)		;COPY 1ST DIM INDEX
;
;	ARRAY OPERAND CALL
;
AOC:	JSR	PC,GETARY		;BRING THE ARRAY INTO CORE IF NOT THERE.
					;AND RETURN ADDRESS OF THE ARRAY ROW (-2)
	JSR	PC,INDEX		;INDEX TAKES THE ADDRESS IN R0 AND RETURNS
					;THE ABSOLUTE ADDRESS OF THE OPERAND IN R0
					;PULLING A SUBSCRIPT OFF OF TOS AND
					;CHECKING FOR INDEXING
	MOV	(R0),-(SP)		;FINALLY TO GET OPERAND DO AN INDIRECT
					;ON THE ADDRESS AND PUSH ONTO TOS
	JMP	INTERP
;
;	ARRAY DESCRIPTOR CALL
;
XADC:	JSR	PC,DIDDLE		;DIDDLE SHUFFLES THE STACK FOR A COMPATIBLE
					;CALL TO GETARY AND INDEX
					;HE RETURNS THE ADDRESS OF THE OPERAND IN R0
	MOV	R0,-(SP)		;PUSH ADDRESS
	JMP	INTERP
;
;	ARRAY STORE DESTRUCT
;
ASD:	JSR	PC,DIDDLE		;SEE ADC
	MOV	(SP)+,(R0)		;STORE VALUE & POP TOS
	BR	SETBIT			;SET READ ONLY BIT
;
;	ARRAY STORE NON-DESTRUCT
;
ASN:	JSR	PC,DIDDLE		;DITTO
	MOV	(SP),(R0)		;STORE VALUE BUT DONT POP STACK
SETBIT:	MOV	MEMADD,R2		;GET MEMORY ADDRESS OF LAST ROW
	BIS	#4,-6(R2)		;TURN ON READ ONLY BIT IN MEMORY DESCRIPTOR
	JMP	INTERP
.SBTTL	SWP ROUTINE
;
;	SWAP	- SWAPS THE POINTERS OF 2 ARRAYS.  THIS INCLUDES THE 
;		  RELATIVE DISK ADDRESSES AS WELL AS THE CORE ADDRESSES
;		  IF PRESENT NOT TO MENTION THE LOWER LIMITS
;
SWP:	MOV	(SP)+,R0		;GET ADDRESS OF 1ST DESCRIPTOR
	MOV	(SP)+,R1		;GET ADDRESS OF 2ND DESCRIPTOR
	MOV	#4,R2			;4 WORDS TO TRANSFER
SWP.LP:	MOV	(R0),-(SP)		;SAVE TEMPORARILY
	MOV	(R1),(R0)+		;STORE SECOND & UPDATE 1ST
	MOV	(SP)+,(R1)+		;STORE 2ND & UPDATE 1ST
	SOB	R2,SWP.LP
	CMP	-(R0),-(R0)		;BACK R0 UP BY 6
	CMP	-(R1),-(R1)		;AND SAME WITH R1 SO THAT BOTH POINT TO THEIR
	CMP	-(R0),-(R1)		;MEMORY LINKS
	TST	-(R0)			;SEE IF FIRST IS PRESENT
	BPL	10$			;ONLY IF NEGATIVE BIT IS ON
	MOV	R0,@2(R0)		;IF SO THEN RESET POINTER TO DESCRIPTOR LOCATED
					;IN MEMORY LINK WORD 4 POINTED TO BY
					;R0 + 2
10$:	TST	-(R1)			;PULL SAME THING WITH SECOND ARRAY
	BPL	20$			;NOT ALLOCATED
	MOV	R1,@2(R1)
20$:	JMP	INTERP
;
;	DIDDLE SHUFFLES THE STACK REMOVING THE VALUE FROM WORD 2
;	THEN HE CALLS GETARY TO BRING THE ARRAY INTO CORE AND FINALLY
;	CALLS INDEX TO DO THE ACTUAL INDEXING & CHECK FOR INVALID INDCES
;
DIDDLE:	MOV	(SP)+,RWT3		;SAVE RETURN ADDRESS
	MOV	2(SP),RWT4		;SAVE VALUE ELSE WHERE
	MOV	(SP)+,(SP)		;PUSH VALUE DOWN TO WHERE IT SHOULD BE
	JSR	PC,GETARY		;GET THE ARRAY
	JSR	PC,INDEX		;AND INDEX INTO IT
	MOV	RWT4,-(SP)		;RETRIEVE OLD VALUE
	JMP	@RWT3			; NON-CONVENTIONAL RETURN FROM SUBROUTINE
.SBTTL	COMM ROUTINE
;
;		C O M M U N I C A T E
;
;	THE COMMUNICATE OPERATOR IS USED TO CALL SELDOM USED ROUTINES
;	WHICH COULD BE ARRANGED TO BE OVERLAID.
;	RIGHT NOW THIS IS NOT THE CASE, BUT IF A CHANGE IS MADE
;	THEN CHANGE ALSO GETARY WHICH CALLS COM01
;
COMM:	MOV	(SP)+,R0		;GET COMMUNICATE #
	SUB	#2,R0			;MINIMUM VALUE ALLOWED IS 2
	BLT	20$			;IF # < 2 THEN ERROR
	CMP	R0,#12			;MAXIMUM # IS 14
	BGT	20$			;IF # > 14 THEN ERROR ALSO
	ASL	R0			;THEN MULTIPLY BY 2
	JMP	@10$(R0)			;CALL THE PROPER ROUTINE
;
;
10$:	COM02				;ALLOCATES AN I/O BUFFER
	COM03				;I/O CALL
	COM04				;ARRAY ROW FILL
	COM05				;TERMINATE JOB
	COM06				;BOOLEAN FILE ATTRIBUTES
	COM07				;ARITHMETIC FILE ATTRIBUTES
	COM10				;FILE FILL
	COM11				;GO TO SOLVER
	COM12				;TIME FUNCTION
	COM13				;STRING TO BINARY TRANSLATE
	COM14

20$:	QUIT	<?Illegal communication function in code file>
;
;	S T K C H K
;
; THIS ROUTINE CHECKS THAT THE STACK POINTER HAS NOT
; EXCEEDED IT'S MEMORY AREA.  THIS AREA IS DELIMITED
; BY THE VALUE IN 'STKLIM'.  IF THE STACK LIMIT IS
; EXCEEDED, A FATAL ERROR IS GENERATED.
;
; CALLING SEQUENCE:
;
;	JSR	PC,STKCHK
;
STKCHK:	CMP	SP,STKLIM		;GONE TOO FAR???
	BLO	10$			;AFRAID SO
	RTS	PC			;NOT THIS TIME

10$:	QUIT	<?Stack overflow>

;
;	S E G C H K
;
; THIS ROUTINE CHECKS THE CURRENT SEGMENT NUMBER AND IPC
; AGAINST A SELECTED SEGMENT ADDRESS STORED IN A TWO WORD
; BLOCK AT ABSOLUTE ADDRESS 320.  IF THE ADDRESSES MATCH
; THEN A TRAP TO ODT IS EXECUTED.
;
;   AT 320:  ALGOL SEGMENT NUMBER
;   AT 322:  RELATIVE ADDRESS WITHIN THE SEGMENT
;
	.IF	DF	DEBUG
SEGCHK:	MOV	@PBASE,R0		;GET POINTER TO PROGRAM DESCRIPTOR
	CMP	P$SGNO(R0),@#320 	;IS THE SEGMENT CORRECT?
	BNE	10$			;NOPE, SO EXIT
	MOV	R5,R0			;RIGHT SEGMENT, COPY IPC
	SUB	PBASE,R0		; AND MAKE IT RELATIVE
	ASR	R0			;  AND IN WORDS
	DEC	R0			; A LITTLE CORRECTION
	CMP	R0,@#322		;IS THIS THE RIGHT PLACE?
	BNE	10$			;NOPE, EXIT
	BPT				;CALL FOR ODT
10$:	RTS	PC			;AND EXIT
	.ENDC

	.END
